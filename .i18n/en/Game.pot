msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Tue Oct 22 01:09:43 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Docs.Definition
msgid "# Conjunction\n"
"## Introduction\n"
"An ‚ÄúAnd‚Äù can be introduced with the `and_intro` theorem. Conjunctions and biconditionals can both be constructed using the angle bracket notation as well.\n"
"### Examples\n"
"```\n"
"-- Assumptions\n"
"p : P\n"
"q : Q\n"
"-- Each new term is evidence for P ‚àß Q\n"
"-- Explicit Constructer, no annotations needed\n"
"have h‚ÇÅ := and_intro p q\n"
"have h‚ÇÇ := and_intro (left := p) (right := q)\n"
"-- Implicit Constructuer, annotations based on context\n"
"-- Type these angle brackets with ‚Äú\\<‚Äù and ‚Äú\\>‚Äù\n"
"have h‚ÇÜ : P ‚àß Q := ‚ü®p,q‚ü©\n"
"have h‚Çá := (‚ü®p,q‚ü© : P ‚àß Q)\n"
"```\n"
"## Elimination\n"
"An ‚ÄúAnd‚Äù like `h : P ‚àß Q` can be reduced in two ways:\n"
"1. Aquire evidence for `P` using `and_left h` or `h.left`\n"
"2. Aquire evidence for `Q` using `and_right` or `h.right`"
msgstr ""

#: Game.Docs.Definition
msgid "# Disjunction\n"
"## Introduction\n"
"An ‚ÄúOr‚Äù like `h : P ‚à® Q` can be introduced in two ways:\n"
"1. If you have `p : P`, you can use `or_inl p`\n"
"2. If you have `q : Q`, you can use `or_inr q`\n"
"\n"
"In either case, remember that the other type in your disjunction must be inferable in context or supplied as part of the expression. For example: `(or_inl p : P ‚à® Q)`\n"
"## Elimination\n"
"An ‚ÄúOr‚Äù like `h : P ‚à® Q` can be be eliminated if both P and Q imply the same proposition. In this example, P or Q implies R:\n"
"```\n"
"-- Assumptions\n"
"pvq: P ‚à® Q\n"
"pr : P ‚Üí R\n"
"qr : Q ‚Üí R\n"
"-- Goal: R\n"
"exact or_elim pvq pr qr\n"
"```"
msgstr ""

#: Game.Docs.Definition
msgid "# False\n"
"This is a proposition for which there can never be any evidence. If your assumptions lead you to evidence for `False`, then your assumptions are inconsitent and you can use `false_elim` to deduce any proposition you like."
msgstr ""

#: Game.Docs.Definition
msgid "# Biconditional\n"
"## Introduction\n"
"An ‚ÄúIf and only if‚Äù can be introduced with the `iff_intro` theorem. Biconditionals and conjunctions can both be constructed using the angle bracket notation as well.\n"
"### Examples\n"
"```\n"
"-- Assumptions\n"
"h‚ÇÅ : P ‚Üí Q\n"
"h‚ÇÇ : Q ‚Üí P\n"
"-- Each new term is evidence for P ‚Üî Q\n"
"-- Explicit Constructer, no annotations needed\n"
"have h‚ÇÅ := iff_intro h‚ÇÅ h‚ÇÇ\n"
"have h‚ÇÇ := iff_intro (mp := h‚ÇÅ) (mpr := h‚ÇÇ)\n"
"-- Implicit Constructuer, annotations based on context\n"
"-- Type these angle brackets with ‚Äú\\<‚Äù and ‚Äú\\>‚Äù\n"
"have h‚ÇÜ : P ‚Üî Q := ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©\n"
"have h‚Çá := (‚ü®h‚ÇÅ, h‚ÇÇ‚ü© : P ‚Üî Q)\n"
"```\n"
"## Elimination\n"
"An ‚ÄúIf and only if‚Äù like `h : P ‚Üî Q` can be reduced in two ways:\n"
"1. Aquire evidence for `P ‚Üí Q` using `iff_mp h` or `h.mp`\n"
"2. Aquire evidence for `Q ‚Üí P` using `iff_mpr h` or `h.mpr`\n"
"## Rewrite\n"
"Biconditionals let you use the `rewrite` tactic to change goals or assumptions."
msgstr ""

#: Game.Docs.Definition
msgid "# Function Application/Implication Elimination\n"
"`P ‚Üí Q` is propostion given to functions from evidence of `P` to evidence of `Q`.\n"
"# Juxtaposition\n"
"Juxtaposition just means ‚Äúto place next to each other,‚Äù which is what we'll do to give a parameter to a function.\n"
"### Example\n"
"```\n"
"-- Assumptions\n"
"e‚ÇÅ : P\n"
"e‚ÇÇ : Q\n"
"Goal:\n"
"P ‚àß Q\n"
"```\n"
"----\n"
"```\n"
"exact (and_intro e‚ÇÅ e‚ÇÇ)\n"
"```\n"
"### Example\n"
"```\n"
"-- Assumptions\n"
"a : A\n"
"h‚ÇÅ : A ‚Üí B\n"
"-- Goal\n"
"B\n"
"```\n"
"---\n"
"```\n"
"exact (h‚ÇÅ a)\n"
"```\n"
"Takes `h‚ÇÅ` and applies `a` to it."
msgstr ""

#: Game.Docs.Definition
msgid "# `fun _ => _`\n"
"You can create evidence for an implication by defining the appropriate function.\n"
"- `have h‚ÇÅ : P ‚Üí P := fun p : P => p`\n"
"- `have h‚ÇÇ : P ‚àß Q ‚Üí P := fun h : P ‚àß Q => h.left`\n"
"\n"
"Generally, you don't need to repeat the types when they're obvious from the context.\n"
"- `have h‚ÇÅ : P ‚Üí P := fun p => p`\n"
"- `have h‚ÇÇ : P ‚àß Q ‚Üí P := fun h => h.left`\n"
"\n"
"# Unicode:\n"
"- `fun` can be written as `Œª`\n"
"- `=>` can be written as `‚Ü¶`\n"
"----\n"
"- `have h‚ÇÅ : P ‚Üí P := Œªp ‚Ü¶ p`\n"
"- `have h‚ÇÇ : P ‚àß Q ‚Üí P := Œªh ‚Ü¶ h.left`"
msgstr ""

#: Game.Docs.Definition
msgid "### **Logic Constants & Operators**\n"
"| $Name~~~$ | $Ascii~~~$ | $Unicode$ | $Unicode Cmd$ |\n"
"| --- | :---: | :---: | --- |\n"
"| True | `True` |  |  |\n"
"| False | `False` |  |  |\n"
"| Not | `Not` | ¬¨ | `\\n` `\\not` `\\neg` `\\lnot` |\n"
"| And | `/\\` | ‚àß | `\\and` `\\an` `\\wedge` |\n"
"| Or | `\\/` | ‚à® | `\\v` `\\or` `\\vee` |\n"
"| Implies | `->` | ‚Üí | `\\r` `\\imp` `\\->` `\\to` `\\r-` `\\rightarrow` |\n"
"| Iff | `<->` | ‚Üî | `\\iff` `\\lr-` `\\lr` `\\<->` `\\leftrightarrow` |\n"
"| For All | `foral` | ‚àÄ | `\\all` `\\forall` |\n"
"| Exists | `exists` | ‚àÉ | `\\ex` `\\exists` |\n"
"\n"
"### **Anonymous Function**\n"
"Example:\n"
"An anonymous function that swaps a conjunction\n"
"```\n"
"-- Ascii\n"
"fun h : P ‚àß Q => and_intro (and_right h) (and_left h)\n"
"-- Unicode\n"
"Œªh : P ‚àß Q ‚Ü¶ ‚ü®h.right, h.left‚ü©\n"
"```\n"
"| $Ascii~~~$ | $Unicode~~~$ | $Unicode Cmd$ |\n"
"| --- | :---: | --- |\n"
"| `fun` | Œª | `\\fun` `\\la` `\\lambda` `\\lamda` `\\lam` `\\Gl` |\n"
"| `=>` | ‚Ü¶ | `\\map` `\\mapsto` |\n"
"\n"
"### **Other Unicode**\n"
"| $Name$ | $Unicode~~~$ | $Unicode Cmd$ |\n"
"| --- | :---: | --- |\n"
"| Angle brackets | ‚ü® ‚ü© | `\\<` `\\>` `\\langle` `\\rangle` |\n"
"| Subscript Numbers | ‚ÇÅ ‚ÇÇ ‚ÇÉ ... | `\\1` `\\2` `\\3` ... |\n"
"| Left Arrow | ‚Üê | `\\l` `\\leftarrow` `\\gets` `\\<-` |\n"
"| Turnstyle | ‚ä¢ | `\\‚îÇ-` `\\entails` `\\vdash` `\\goal` |"
msgstr ""

#: Game.Docs.Definition
msgid "# Remembering Algebra\n"
"In math class, you may have learned an acronym like BEDMAS or PEMDAS to remember the precedence of operators in your math expressions:\n"
"1. Brackets (or Parentheses)\n"
"2. Exponents\n"
"3. Division or Multiplication\n"
"4. Addition or Subtraction\n"
"\n"
"These rules exist for the logical operators as well.\n"
"# Brackets\n"
"Brackets group or disambiguate expressions. You can think of precedence rules as deciding where brackets belong. If an operator is an infix operator, then it has an associativity as well.\n"
"- right-associative: `P ‚àß Q ‚àß R` ‚â° `P ‚àß (Q ‚àß R)`\n"
"- left-associative: `1 + 2 + 3` ‚â° `(1 + 2) + 3`\n"
"- non-associative: `P ‚Üî Q ‚Üî R` is an error\n"
"# High to low Precedence\n"
"Function application doesn't have an operator, it's just `function <space> argument`. It has max precedence and is left associative (meaning `and_intro p q` ‚â° `(and_intro p) q`).\n"
"### Propositional Operators\n"
"| $Operator$ | $~~~Precedence$ | |\n"
"| :---: | :---: | --- |\n"
"| ¬¨ | max | |\n"
"| ‚àß | 35 | right-associative |\n"
"| ‚à® | 30 | right-associative |\n"
"| ‚Üí | 25 | right-associative |\n"
"| ‚Üî | 20 | non-associative |\n"
"| ‚àÉ | __ | |\n"
"| ‚àÄ | __ | |\n"
"### Expression Operators\n"
"| $Operator$ | $~~~Precedence$ | |\n"
"| :---: | :---: | --- |\n"
"| ‚â´ | 85 | left-associative |\n"
"| |> | min + 1 | right-associative |\n"
"| <| | min | left-associative |\n"
"### Example:\n"
"```\n"
"¬¨P ‚à® Q ‚àß P ‚Üí Q ‚Üî Q ‚à® R ‚à® ¬¨S\n"
"-- ¬¨ binds the tightest:\n"
"(¬¨P) ‚à® Q ‚àß P ‚Üí Q ‚Üî Q ‚à® R ‚à® (¬¨S)\n"
"-- Next is ‚àß\n"
"(¬¨P) ‚à® (Q ‚àß P) ‚Üí Q ‚Üî Q ‚à® R ‚à® (¬¨S)\n"
"-- Next is ‚à®, associated right\n"
"(¬¨P) ‚à® (Q ‚àß P) ‚Üí Q ‚Üî Q ‚à® (R ‚à® (¬¨S))\n"
"-- The rest of ‚à®\n"
"((¬¨P) ‚à® (Q ‚àß P)) ‚Üí Q ‚Üî (Q ‚à® (R ‚à® (¬¨S)))\n"
"-- Next is ‚Üí\n"
"(((¬¨P) ‚à® (Q ‚àß P)) ‚Üí Q) ‚Üî (Q ‚à® (R ‚à® (¬¨S)))\n"
"-- No more steps as this is fully disambiguated\n"
"```\n"
"Here's a version where you can see it aligned\n"
"```\n"
"   ¬¨P  ‚à®  Q ‚àß P   ‚Üí Q  ‚Üî  Q ‚à®  R ‚à®  ¬¨S\n"
"  (¬¨P) ‚à®  Q ‚àß P   ‚Üí Q  ‚Üî  Q ‚à®  R ‚à® (¬¨S)\n"
"  (¬¨P) ‚à® (Q ‚àß P)  ‚Üí Q  ‚Üî  Q ‚à®  R ‚à® (¬¨S)\n"
"  (¬¨P) ‚à® (Q ‚àß P)  ‚Üí Q  ‚Üî  Q ‚à® (R ‚à® (¬¨S))\n"
" ((¬¨P) ‚à® (Q ‚àß P)) ‚Üí Q  ‚Üî (Q ‚à® (R ‚à® (¬¨S)))\n"
"(((¬¨P) ‚à® (Q ‚àß P)) ‚Üí Q) ‚Üî (Q ‚à® (R ‚à® (¬¨S)))\n"
"```"
msgstr ""

#: Game.Docs.Lemmas
msgid "# ‚àß Elimination Left\n"
"### `and_left : P ‚àß Q -> P`\n"
"\n"
"If `h` is a term with a type like `P ‚àß Q`\n"
"\n"
"`and_left h`, `h.left` or `h.1` are all expressions for denoting the left-hand side of the given evidence. In this case, the left side has a type of `P`."
msgstr ""

#: Game.Docs.Lemmas
msgid "# ‚àß Elimination Right\n"
"### `and_right : P ‚àß Q -> Q`\n"
"\n"
"If `h` is a term with a type like `P ‚àß Q`\n"
"\n"
"`and_right h`, `h.right` or `h.2` are all expressions for denoting the right-hand side of the given evidence. In this case, the left side has a type of `Q`."
msgstr ""

#: Game.Docs.Lemmas
msgid "# and_intro\n"
"### `and_intro : P -> Q -> P ‚àß Q`\n"
"`and_intro` is a function with two parameters. It takes two disparate pieces of evidence and combines them into a single piece of evidence. If `(e‚ÇÅ : P)` and `(e‚ÇÇ : Q)` are evidence, then\n"
"```\n"
"have h : P ‚àß Q := and_intro e‚ÇÅ e‚ÇÇ\n"
"```"
msgstr ""

#: Game.Docs.Lemmas
msgid "If\n"
"```\n"
"-- Assumptions\n"
"h : False\n"
"```\n"
"then\n"
"```\n"
"have t : T := false_elim h\n"
"```\n"
"will allow you to write any well formed proposition in place of `T`. This makes `false_elim` the \\\"From `False`, anything goes\\\" function. **Ex falso quodlibet**."
msgstr ""

#: Game.Docs.Lemmas
msgid "# Or Introduction Left\n"
"Turns evidence for the lefthand of an `‚à®` proposition into a disjunction. The context must supply what the righthand side of the disjunction is.\n"
"```\n"
"-- Objects\n"
"P Q : Prop\n"
"-- Assumptions\n"
"p : P\n"
"```\n"
"allows:\n"
"```\n"
"have h : P ‚à® Q := or_inl p\n"
"have h := (or_inl p : P ‚à® Q)\n"
"have h := show P ‚à® Q from or_inl p\n"
"```"
msgstr ""

#: Game.Docs.Lemmas
msgid "# Or Introduction Right\n"
"Turns evidence for the righthand of an `‚à®` proposition into a disjunction. The context must supply what the lefthand side of the disjunction is.\n"
"```\n"
"-- Objects\n"
"P Q : Prop\n"
"-- Assumptions\n"
"q : Q\n"
"```\n"
"allows:\n"
"```\n"
"have h : P ‚à® Q := or_inr q\n"
"have h := (or_inl q : P ‚à® Q)\n"
"have h := show P ‚à® Q from or_inl q\n"
"```\n"
"\""
msgstr ""

#: Game.Docs.Lemmas
msgid "# Or Elimination\n"
"If you can conclude something from `A` and you can conclude the same thing from `B`, then if you know `A ‚à® B` it won't matter which of the two happens as you can still guarantee something.\n"
"\n"
"or_elim is also evidence:\n"
"```\n"
"or_elim : (P ‚à® Q) ‚Üí (P ‚Üí R) ‚Üí (Q ‚Üí R) ‚Üí R`\n"
"```\n"
"# Parameters\n"
"`or_elim` has three parameters:\n"
"1. takes evidence for a disjunction,\n"
"2. evidence an implication on the left,\n"
"3. evidence for an implication on the right.\n"
"# Example\n"
"`or_elim` is your first 3-parameter function.\n"
"```\n"
"pvq: P ‚à® Q\n"
"pr : P ‚Üí R\n"
"qr : Q ‚Üí R\n"
"have r : R := or_elim pvq pr qr\n"
"```"
msgstr ""

#: Game.Docs.Lemmas
msgid "# Propositional Equivalence\n"
"`P ‚Üî Q` means that `P` and `Q` must have the same truth value. This is often said as ‚Äú`P` if and only iff `Q`‚Äù or ‚Äú`P` is logically equivalent to `Q`‚Äù.\n"
"\n"
"`iff_intro` is the way to prove a biconditional like `P ‚Üî Q`. It requires you to show evidence for both `P ‚Üí Q` and `Q ‚Üí P`."
msgstr ""

#: Game.Docs.Lemmas
msgid "If you have an assumption like `h : P ‚Üî Q`, then\n"
"```\n"
"iff_mp h -- or\n"
"h.mp     -- is evidence for P ‚Üí Q\n"
"\n"
"iff_mpr h -- or\n"
"h.mpr     -- is evidence for Q ‚Üí P\n"
"```"
msgstr ""

#: Game.Docs.Lemmas
msgid "If you have an assumption like `h : P ‚Üî Q`, then\n"
"```\n"
"iff_mp h -- or\n"
"h.mp     -- is evidence for P ‚Üí Q\n"
"\n"
"iff_mpr h -- or\n"
"h.mpr     -- is evidence for Q ‚Üí P\n"
"```"
msgstr ""

#: Game.Docs.Lemmas
msgid "In this game, the deductive rule *modus_ponens* is just function application.\n"
"```\n"
"intro h : A ‚àß B\n"
"have a : A := and_left h\n"
"-- could be written as\n"
"have a : A := modus_ponens and_left h\n"
"```\n"
"and\n"
"```\n"
"intro a : A\n"
"intro b : B\n"
"have h : A ‚àß B := and_intro a b\n"
"-- could be written as\n"
"have h : A ‚àß B := modus_ponens (modus_ponens and_intro a) b\n"
"```\n"
"\n"
"You should never use this style of prefix `modus_ponens` and just use function application instead as that will generally be clearer.\n"
"\n"
"----\n"
"# Infix Modus Ponens\n"
"There is are infix operators for function application; they look like `|>` and `<|`. `f <| x`, and `x |> f` means the same as the same as `f x`.\n"
"\n"
"`<|` parses `x` with lower precedence, which means that `f <| g $ <|` is interpreted as `(f (g x))` rather than `((f g) x)`.\n"
"\n"
"It's twin, `|>` chains such that `x |> f |> g` is interpreted as `g (f x)`.\n"
"\n"
"What makes the infix operators useful is that they can often replace a pair of brackets `(...)` making expressions easier to read.\n"
"\n"
"----\n"
"# Computer Science\n"
"If you've done some programming before, you might recognise `Modus Ponens` as the identity function for implications. So `(modus_ponens and_left)` is extensionally equal to `and_left`. There's a conspiracy at work here!"
msgstr ""

#: Game.Docs.Lemmas
msgid "# ‚àß is commutative\n"
"\n"
"`and_comm` is evidence that `P ‚àß Q ‚Üî Q ‚àß P`"
msgstr ""

#: Game.Docs.Lemmas
msgid "# ‚àß is Associative\n"
"\n"
"`and_assoc` is evidence that `(P ‚à® Q) ‚à® R ‚Üî P ‚à® Q ‚à® R`"
msgstr ""

#: Game.Docs.Lemmas
msgid "# ‚à® is commutative\n"
"\n"
"`or_comm` is evidence that `P ‚à® Q ‚Üî Q ‚à® P`"
msgstr ""

#: Game.Docs.Lemmas
msgid "# ‚à® is Associative\n"
"\n"
"`or_assoc` is evidence that `P ‚à® Q ‚à® R ‚Üî (P ‚à® Q) ‚à® R`"
msgstr ""

#: Game.Docs.Lemmas
msgid "# ‚Üí is transitive\n"
"`P ‚Üí Q` and `Q ‚Üí R` implies `P ‚Üí R`\n"
"```\n"
"imp_trans : (P ‚Üí Q) ‚Üí (Q ‚Üí R) ‚Üí P ‚Üí R\n"
"```\n"
"\n"
"Of course, because of `and_comm`, you know you can flip this around too.\n"
"`Q ‚Üí R` and `P ‚Üí Q` implies `P ‚Üí R` has a near-identical proof.\n"
"\n"
"### Infix Operator:\n"
"`imp_trans` has an infix operator. This looks like `‚â´` (which is written as ‚Äú`\\gg`‚Äù).\n"
"\n"
"For the math-inclined, because the expression for an implication is a function, you can also use function composition for the same purpose (`‚àò` is written as ‚Äú`\\o`‚Äù). Just remember that `‚àò` has the parameters swapped from the way `imp_trans` is defined."
msgstr ""

#: Game.Docs.Lemmas
msgid "# Negation is stable\n"
"A nice result of this theorem is that any more than 2 negations can be simplified down to 1 or 2 negations.\n"
"```\n"
"not_not_not : ¬¨¬¨¬¨P ‚Üî ¬¨P\n"
"```"
msgstr ""

#: Game.Docs.Lemmas
msgid "# Modus Tollens\n"
"Denying the consequent.\n"
"\n"
"If P, then Q.\\\n"
"Not Q.\\\n"
"Therefore, not P.\n"
"```\n"
"mt : (P ‚Üí Q) ‚Üí ¬¨Q ‚Üí ¬¨P\n"
"```\n"
"\n"
"### Infix Operator:\n"
"`modus_tollens` is a specialized version of `imp_trans`, which makes it possible to use `‚â´` (which is written as ‚Äú`\\gg`‚Äù) as an infix operator for `modus_tollens`."
msgstr ""

#: Game.Docs.Lemmas
msgid "# Propositional Identity\n"
"This is the \\\"I think therefore I am\\\" of propositional logic. Like `True` it is a simple tautology whose truth requires no premises or assumptions ‚Äî only reason alone.\n"
"```\n"
"identity : P ‚Üí P\n"
"```"
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "On: rfl"
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical theorem (the \"Goal\").\n"
"The goal will be a statement about *numbers*. Some numbers in this game have known values.\n"
"Those numbers have names like $37$. Other numbers will be secret. They're called things\n"
"like $x$ and $q$. We know $x$ is a number, we just don't know which one.\n"
"\n"
"In this first level we're going to prove the theorem that $37x + q = 37x + q$.\n"
"You can see `x q : ‚Ñï` in the *Objects* below, which means that `x` and `q`\n"
"are numbers.\n"
"\n"
"We solve goals in Lean using *Tactics*, and the first tactic we're\n"
"going to learn is called `rfl`, which proves all theorems of the form $X = X$.\n"
"\n"
"Prove that $5x+q=5x+q$ by executing the `rfl` tactic."
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "If $x, q ‚àà ‚Ñï$, then $5x + q = 5x + q$"
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "In order to use the tactic `rfl` you can enter it in the text box\n"
"under the goal and hit \"Execute\"."
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "Congratulations! You completed your first verified proof!\n"
"\n"
"Remember that `rfl` is a *tactic*. If you ever want information about the `rfl` tactic,\n"
"you can click on `rfl` in the list of tactics on the right.\n"
"\n"
"Now click on \"Next\" to learn about the `rw` tactic."
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\".\n"
"\n"
"## Game Implementation\n"
"\n"
"*Note that our `rfl` is weaker than the version used in core Lean and `mathlib`,\n"
"for pedagogical purposes; mathematicians do not distinguish between propositional\n"
"and definitional equality because they think about definitions in a different way\n"
"to type theorists (`zero_add` and `add_zero` are both \\\"facts\\\" as far\n"
"as mathematicians are concerned, and who cares what the definition of addition is).*"
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "the rw tactic"
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targetted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rewrite 37 [h]`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "In this level the *goal* is $2y=2(x+7)$ but to help us we\n"
"have an *assumption* `h` saying that $y = x + 7$. Check that you can see `h` in\n"
"your list of assumptions. Lean thinks of `h` as being a secret proof of the\n"
"assumption, rather like `x` is a secret number.\n"
"\n"
"Before we can use `rfl`, we have to \"substitute in for $y$\".\n"
"We do this in Lean by *rewriting* the proof `h`,\n"
"using the `rw` tactic."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "If $x$ and $y$ are natural numbers, and $y = x + 7$, then $2y = 2(x + 7)$."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "First execute `rw [h]` to replace the `y` with `x + 7`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "Can you take it from here? Click on \"Show more help!\" if you need a hint."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "Now `rfl` will work."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "You now know enough tactics to prove `1 + 1 = 2`! Let's begin the journey."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Numbers"
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`‚Ñï` is the natural numbers, just called \\\"numbers\\\" in this game. It's\n"
"defined via two rules:\n"
"\n"
"* `0 : ‚Ñï` (zero is a number)\n"
"* `succ (n : ‚Ñï) : ‚Ñï` (the successor of a number is a number)\n"
"\n"
"## Game Implementation\n"
"\n"
"*The game uses its own copy of the natural numbers, called `MyNat` with notation `‚Ñï`.\n"
"It is distinct from the Lean natural numbers `Nat`, which should hopefully\n"
"never leak into the natural number game.*"
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`one_eq_succ_zero` is a proof of `1 = succ 0`.\""
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`two_eq_succ_one` is a proof of `2 = succ 1`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`three_eq_succ_two` is a proof of `3 = succ 2`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`four_eq_succ_three` is a proof of `4 = succ 3`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "## The birth of number.\n"
"\n"
"Numbers in Lean are defined by two rules.\n"
"\n"
"* `0` is a number.\n"
"* If `n` is a number, then the *successor* `succ n` of `n` is a number.\n"
"\n"
"The successor of `n` means the number after `n`. Let's learn to\n"
"count, and name a few small numbers.\n"
"\n"
"## Counting to four.\n"
"\n"
"`0` is a number, so `succ 0` is a number. Let's call this new number `1`.\n"
"Similarly let's define `2 = succ 1`, `3 = succ 2` and `4 = succ 3`.\n"
"This gives us plenty of numbers to be getting along with.\n"
"\n"
"The *proof* that `2 = succ 1` is called `two_eq_succ_one`.\n"
"Check out the \"012\" tab in the list of lemmas on the right\n"
"for this and other proofs.\n"
"\n"
"Let's prove that $2$ is the number after the number after zero."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "$2$ is the number after the number after $0$."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Start with `rw [two_eq_succ_one]` to begin to break `2` down into its definition."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Can you take it from here?"
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Next turn `1` into `succ 0` with `rw [one_eq_succ_zero]`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Now finish the job with `rfl`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Note that you can do `rw [two_eq_succ_one, one_eq_succ_zero]`\n"
"and then `rfl` to solve this level in two lines."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "rewriting backwards"
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "If `h` is a proof of `X = Y` then `rw [h]` will\n"
"turn `X`s into `Y`s. But what if we want to\n"
"turn `Y`s into `X`s? To tell the `rw` tactic\n"
"we want this, we use a left arrow `‚Üê`. Type\n"
"`\\l` and then hit the space bar to get this arrow.\n"
"\n"
"Let's prove that $2$ is the number after the number\n"
"after $0$ again, this time by changing `succ (succ 0)`\n"
"into `2`."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "$2$ is the number after the number after $0$."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Try `rw [‚Üê one_eq_succ_zero]` to change `succ 0` into `1`."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Can you now change the goal into `2 = 2`?"
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Now `rw [‚Üê two_eq_succ_one]` will change `succ 1` into `2`."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Why did we not just define `succ n` to be `n + 1`? Because we have not\n"
"even *defined* addition yet! We'll do that in the next level."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "Adding zero"
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "`Add a b`, with notation `a + b`, is\n"
"the usual sum of natural numbers. Internally it is defined\n"
"via the following two hypotheses:\n"
"\n"
"* `add_zero a : a + 0 = a`\n"
"\n"
"* `add_succ a b : a + succ b = succ (a + b)`\n"
"\n"
"Other theorems about naturals, such as `zero_add a : 0 + a = a`, are proved\n"
"by induction using these two basic theorems.\""
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "`add_zero a` is a proof that `a + 0 = a`.\n"
"\n"
"## Summary\n"
"\n"
"`add_zero` is really a function, which\n"
"eats a number, and returns a proof of a theorem\n"
"about that number. For example `add_zero 37` is\n"
"a proof that `37 + 0 = 37`.\n"
"\n"
"The `rw` tactic will accept `rw [add_zero]`\n"
"and will try to figure out which number you omitted\n"
"to input.\n"
"\n"
"## Details\n"
"\n"
"A mathematician sometimes thinks of `add_zero`\n"
"as \\\"one thing\\\", namely a proof of $\\forall n ‚àà ‚Ñï, n + 0 = n$.\n"
"This is just another way of saying that it's a function which\n"
"can eat any number n and will return a proof that `n + 0 = n`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "We'd like to prove `2 + 2 = 4` but right now\n"
"we can't even *state* it\n"
"because we haven't yet defined addition.\n"
"\n"
"## Defining addition.\n"
"\n"
"How are we going to add $37$ to an arbitrary number $x$? Well,\n"
"there are only two ways to make numbers in this game: $0$\n"
"and successors. So to define `37 + x` we will need\n"
"to know what `37 + 0` is and what `37 + succ x` is.\n"
"Let's start with adding `0`.\n"
"\n"
"### Adding 0\n"
"\n"
"To make addition agree with our intuition, we should *define* `37 + 0`\n"
"to be `37`. More generally, we should define `a + 0` to be `a` for\n"
"any number `a`. The name of this proof in Lean is `add_zero a`.\n"
"For example `add_zero 37` is a proof of `37 + 0 = 37`,\n"
"`add_zero x` is a proof of `x + 0 = x`, and `add_zero` is a proof\n"
"of `? + 0 = ?`.\n"
"\n"
"We write `add_zero x : x + 0 = x`, so `proof : statement`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "$a+(b+0)+(c+0)=a+b+c.$"
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "`rw [add_zero]` will change `b + 0` into `b`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "Now `rw [add_zero]` will change `c + 0` into `c`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "Those of you interested in speedrunning the game may want to know\n"
"that `repeat rw [add_zero]` will do both rewrites at once."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "Precision rewriting"
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "## Precision rewriting\n"
"\n"
"In the last level, there was `b + 0` and `c + 0`,\n"
"and `rw [add_zero]` changed the first one it saw,\n"
"which was `b + 0`. Let's learn how to tell Lean\n"
"to change `c + 0` first by giving `add_zero` an\n"
"explicit input."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "$a+(b+0)+(c+0)=a+b+c.$"
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "Try `rw [add_zero c]`."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "`add_zero c` is a proof of `c + 0 = c` so that was what got rewritten.\n"
"You can now change `b + 0` to `b` with `rw [add_zero]` or `rw [add_zero b]`. You\n"
"can usually stick to `rw [add_zero]` unless you need real precision."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "Let's now learn about Peano's second axiom for addition, `add_succ`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "add_succ"
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "`add_succ a b` is the proof of `a + succ b = succ (a + b)`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "`succ_eq_add_one n` is the proof that `succ n = n + 1`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "Every number in Lean is either $0$ or a successor. We know how to add $0$,\n"
"but we need to figure out how to add successors. Let's say we already know\n"
"that `37 + d = q`. What should the answer to `37 + succ d` be? Well,\n"
"`succ d` is one bigger than `d`, so `37 + succ d` should be `succ q`,\n"
"the number one bigger than `q`. More generally `x + succ d` should\n"
"be `succ (x + d)`. Let's add this as a lemma.\n"
"\n"
"* `add_succ x d : x + succ d = succ (x + d)`\n"
"\n"
"If you ever see `... + succ ...` in your goal, `rw [add_succ]` is\n"
"normally a good idea.\n"
"\n"
"Let's now prove that `succ n = n + 1`. Figure out how to get `+ succ` into\n"
"the picture, and then `rw [add_succ]`. Switch between the `+` (addition) and\n"
"`012` (numerals) tabs under \"Theorems\" on the right to\n"
"see which proofs you can rewrite."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "For all natural numbers $a$, we have $\\operatorname{succ}(a) = a+1$."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "Start by unravelling the `1`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "`rw [one_eq_succ_zero]` will do this."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "Now you can `rw [add_succ]`"
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "And now `rw [add_zero]`"
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "And finally `rfl`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "[dramatic music]. Now are you ready to face the first boss of the game?"
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "1+1=2"
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "Good luck!\n"
"\n"
"  One last hint. If `h : X = Y` then `rw [h]` will change *all* `X`s into `Y`s.\n"
"  If you only want to change one of them, say the 3rd one, then use\n"
"  `nth_rewrite 3 [h]`."
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "$1+1=2$."
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "Here's another proof of $1 + 1 = 2$ that uses less lines:\n"
"```lean\n"
"nth_rewrite 2 [one_eq_succ_zero] -- Changes only the second one\n"
"rw [add_succ]\n"
"rw [add_zero]\n"
"rw [‚Üê two_eq_succ_one] -- change `succ 1` to `2`\n"
"rfl\n"
"```\n"
"\n"
"Optional extra: you can run this proof yourself. Switch the game into \"Editor mode\" by clicking\n"
"on the `</>` button in the top right. You can now see your proof\n"
"written as several lines of code. Move your cursor between lines to see\n"
"the goal state at any point. Now cut and paste your code elsewhere if you\n"
"want to save it, and paste the above proof in instead. Move your cursor\n"
"around to investigate. When you've finished, click the `>_` button in the top right to\n"
"move back into \"Typewriter mode\".\n"
"\n"
"You have finished the Basics world!\n"
"Click \"Leave World\" to go back to the\n"
"overworld, and select Addition World, where you will learn\n"
"about the `induction` tactic."
msgstr ""

#: Game.Levels.Basics
msgid "The Basics of Lean"
msgstr ""

#: Game.Levels.Basics
msgid "This introduction is shown before one enters level 1 of the demo world. Use markdown."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "zero_add"
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "In this level we're going to prove that $0+n=n$, where $n$ is a secret natural number.\n"
"\n"
"Wait, don't we already know that? No! We know that $n+0=n$, but that's `add_zero`.\n"
"This is `zero_add`, which is different.\n"
"\n"
"The difficulty with proving `0 + n = n` is that we do not have a *formula* for\n"
"`0 + n` in general, we can only use `add_zero` and `add_succ` once\n"
"we know whether `n` is `0` or a successor. The `induction` tactic splits into these two cases.\n"
"\n"
"The base case will require us to prove `0 + 0 = 0`, and the inductive step\n"
"will ask us to show that if `0 + d = d` then `0 + succ d = succ d`. Because\n"
"`0` and successor are the only way to make numbers, this will cover all the cases.\n"
"\n"
"See if you can do your first induction proof in Lean.\n"
"\n"
"(By the way, if you are still in the \"Editor mode\" from the last world, you can swap\n"
"back to \"Typewriter mode\" by clicking the `>_` button in the top right.)"
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "`zero_add x` is the proof of `0 + x = x`.\n"
"\n"
"`zero_add` is a `simp` lemma, because replacing `0 + x` by `x`\n"
"is almost always what you want to do if you're simplifying an expression."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "For all natural numbers $n$, we have $0 + n = n$."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "You can start a proof by induction on `n` by typing:\n"
"`induction n with d hd`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "Now you have two goals. Once you proved the first, you will jump to the second one.\n"
"This first goal is the base case $n = 0$.\n"
"\n"
"Recall that you can rewrite the proof of any lemma which is visible\n"
"in your inventory, or of any assumption displayed above the goal,\n"
"as long as it is of the form `X = Y`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "try rewriting `add_zero`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "Now for to the second goal. Here you have the induction hypothesis\n"
"`¬´{hd}¬ª : 0 + ¬´{d}¬ª = ¬´{d}¬ª`, and you need to prove that `0 + succ ¬´{d}¬ª = succ ¬´{d}¬ª`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "Use `add_succ`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "At this point you see the term `0 + ¬´{d}¬ª`, so you can use the\n"
"induction hypothesis with `rw [¬´{hd}¬ª]`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "## Summary\n"
"\n"
"If `n : ‚Ñï` is an object, and the goal mentions `n`, then `induction n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "This lemma would have been easy if we had known that `x + y = y + x`. That theorem\n"
"  is called `add_comm` and it is *true*, but unfortunately its proof *uses* both\n"
"  `add_zero` and `zero_add`!\n"
"\n"
"  Let's continue on our journey to `add_comm`, the proof of `x + y = y + x`."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "succ_add"
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Oh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add a b`\n"
"is the proof that `(succ a) + b = succ (a + b)` for `a` and `b` numbers.\n"
"This result is what's standing in the way of `x + y = y + x`. Again\n"
"we have the problem that we are adding `b` to things, so we need\n"
"to use induction to split into the cases where `b = 0` and `b` is a successor."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "`succ_add a b` is a proof that `succ a + b = succ (a + b)`."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "For all natural numbers $a, b$, we have\n"
"$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "You might want to think about whether induction\n"
"on `a` or `b` is the best idea."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Induction on `a` will not work here. You are still stuck with an `+ b`.\n"
"I suggest you delete this line and try a different approach."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Note that `succ a + ¬´{d}¬ª` means `(succ a) + ¬´{d}¬ª`. Put your cursor\n"
"on any `succ` in the goal or assumptions to see what exactly it's eating."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Well done! You now have enough tools to tackle the main boss of this level."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "add_comm (level boss)"
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "[boss battle music]\n"
"Time to prove one of the most important properties yet: Addition's Commutativity\n"
"\n"
"Look in your inventory to see the proofs you have available.\n"
"These should be enough."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "`add_comm x y` is a proof of `x + y = y + x`."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "On the set of natural numbers, addition is commutative.\n"
"In other words, if `a` and `b` are arbitrary natural numbers, then\n"
"$a + b = b + a$."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "Induction on `a` or `b` -- it's all the same in this one."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "add_assoc (associativity of addition)"
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "We've been adding up two numbers; in this level we will add up three.\n"
"\n"
"  What does $x+y+z$ *mean*? It could either mean $(x+y)+z$, or it\n"
"  could mean $x+(y+z)$. In Lean, $x+y+z$ means $(x+y)+z$.\n"
"\n"
"  But why do we care which one it means; $(x+y)+z$ and $x+(y+z)$ are *equal*!\n"
"\n"
"  That's true, but we didn't prove it yet. Let's prove it now by induction."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "`add_assoc a b c` is a proof\n"
"that `(a + b) + c = a + (b + c)`. Note that in Lean `(a + b) + c` prints\n"
"as `a + b + c`, because the notation for addition is defined to be left\n"
"associative."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "On the set of natural numbers, addition is associative.\n"
"In other words, if $a, b$ and $c$ are arbitrary natural numbers, we have\n"
"$ (a + b) + c = a + (b + c). $"
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "Remember that when Lean writes `a + b + c`, it means `(a + b) + c`.\n"
"If you are not sure where the brackets are in an expression, just hover\n"
"your cursor over it and look at what gets highlighted. For example,\n"
"hover over both `+` symbols on the left hand side of the goal and\n"
"you'll see where the invisible brackets are."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "A passing mathematician congratulates you on proving that naturals\n"
"are an additive commutative monoid.\n"
"\n"
"Let's practice using `add_assoc` and `add_comm` in one more level,\n"
"before we leave addition world."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "add_right_comm"
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "`add_comm b c` is a proof that `b + c = c + b`. But if your goal\n"
"is `a + b + c = a + c + b` then `rw [add_comm b c]` will not\n"
"work! Because the goal means `(a + b) + c = (a + c) + b` so there\n"
"is no `b + c` term *directly* in the goal.\n"
"\n"
"Use associativity and commutativity to prove `add_right_comm`.\n"
"You don't need induction. `add_assoc` moves brackets around,\n"
"and `add_comm` moves variables around.\n"
"\n"
"Remember that you can do more targetted rewrites by\n"
"adding explicit variables as inputs to theorems. For example `rw [add_comm b]`\n"
"will only do rewrites of the form `b + ? = ? + b`, and `rw [add_comm b c]`\n"
"will only do rewrites of the form `b + c = c + b`."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "`add_right_comm a b c` is a proof that `(a + b) + c = (a + c) + b`\n"
"\n"
"In Lean, `a + b + c` means `(a + b) + c`, so this result gets displayed\n"
"as `a + b + c = a + c + b`."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "If $a, b$ and $c$ are arbitrary natural numbers, we have\n"
"$(a + b) + c = (a + c) + b$."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "You've now seen all the tactics you need to beat the final boss of the game.\n"
"You can begin the journey towards this boss by entering Multiplication World.\n"
"\n"
"Or you can go off the beaten track and learn some new tactics in Implication\n"
"World. These tactics let you prove more facts about addition, such as\n"
"how to deduce `a = 0` from `x + a = x`.\n"
"\n"
"Click \"Leave World\" and make your choice."
msgstr ""

#: Game.Levels.Addition
msgid "Addition World"
msgstr ""

#: Game.Levels.Addition
msgid "Welcome to Addition World! In this world we'll learn the `induction` tactic.\n"
"This will enable us to defeat the boss level of this world, namely `x + y = y + x`.\n"
"\n"
"The tactics `rw`, `rfl` and `induction` are the only tactics you'll need to\n"
"beat all the levels in Addition World, Multiplication World, and Power World.\n"
"Power World contains the final boss of the game.\n"
"\n"
"There are plenty more tactics in this game, but you'll only need to know them if you\n"
"want to explore the game further (for example if you decide to 100%\n"
"the game)."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "mul_one"
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "See the new \"*\" tab in your lemmas, containing `mul_zero` and `mul_succ`.\n"
"Right now these are the only facts we know about multiplication.\n"
"Let's prove nine more.\n"
"\n"
"Let's start with a warm-up: no induction needed for this one,\n"
"because we know `1` is a successor."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`Mul a b`, with notation `a * b`, is the usual\n"
"  product of natural numbers. Internally it is\n"
"  via two axioms:\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"\n"
"  * `mul_succ a b : a * succ b = a * b + a`\n"
"\n"
"Other theorems about naturals, such as `zero_mul`,\n"
"are proved by induction from these two basic theorems."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`mul_zero m` is the proof that `m * 0 = 0`."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`mul_succ a b` is the proof that `a * succ b = a * b + a`."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`mul_one m` is the proof that `m * 1 = m`."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "For any natural number $m$, we have $ m \\times 1 = m$."
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "zero_mul"
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "Our first challenge is `mul_comm x y : x * y = y * x`,\n"
"and we want to prove it by induction. The zero\n"
"case will need `mul_zero` (which we have)\n"
"and `zero_mul` (which we don't), so let's\n"
"start with this."
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "`zero_mul x` is the proof that `0 * x = 0`.\n"
"\n"
"Note: `zero_mul` is a `simp` lemma."
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "For all natural numbers $m$, we have $ 0 \\times m = 0$."
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "succ_mul"
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "Similarly we have `mul_succ`\n"
"but we're going to need `succ_mul` (guess what it says -- maybe you\n"
"are getting the hang of Lean's naming conventions).\n"
"\n"
"The last level from addition world might help you in this level.\n"
"If you can't remember what it is, you can go back to the\n"
"home screen by clicking the house icon and then taking a look.\n"
"You won't lose any progress."
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "`succ_mul a b` is the proof that `succ a * b = a * b + b`.\n"
"\n"
"It could be deduced from `mul_succ` and `mul_comm`, however this argument\n"
"would be circular because the proof of `mul_comm` uses `mul_succ`."
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "For all natural numbers $a$ and $b$, we have\n"
"$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$."
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "mul_comm"
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "The first sub-boss of Multiplication World is `mul_comm x y : x * y = y * x`.\n"
"\n"
"When you've proved this theorem we will have \"spare\" proofs\n"
"such as `zero_mul`, which is now easily deducible from `mul_zero`.\n"
"But we'll keep hold of these proofs anyway, because it's convenient\n"
"to have exactly the right tool for a job."
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "`mul_comm` is the proof that multiplication is commutative. More precisely,\n"
"`mul_comm a b` is the proof that `a * b = b * a`."
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "Multiplication is commutative."
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "one_mul"
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "You can prove $1\\times m=m$ in at least three ways.\n"
"Either by induction, or by using `succ_mul`, or\n"
"by using commutativity. Which do you think is quickest?"
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "`one_mul m` is the proof `1 * m = m`."
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "For any natural number $m$, we have $ 1 \\times m = m$."
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "Here's my solution:\n"
"```\n"
"rw [mul_comm, mul_one]\n"
"rfl\n"
"```"
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "two_mul"
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "This level is more important than you think; it plays\n"
"a useful role when battling a big boss later on."
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "`two_mul m` is the proof that `2 * m = m + m`."
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "For any natural number $m$, we have $ 2 \\times m = m+m$."
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "Here's my solution:\n"
"```\n"
"rw [two_eq_succ_one, succ_mul, one_mul]\n"
"rfl\n"
"```"
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "mul_add"
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Our next goal is \"left and right distributivity\",\n"
"meaning $a(b+c)=ab+ac$ and $(b+c)a=ba+ca$. Rather than\n"
"these slightly pompous names, the name of the proofs\n"
"in Lean are descriptive. Let's start with\n"
"`mul_add a b c`, the proof of `a * (b + c) = a * b + a * c`.\n"
"Note that the left hand side contains a multiplication\n"
"and then an addition."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Multiplication distributes\n"
"over addition on the left.\n"
"\n"
"`mul_add a b c` is the proof that `a * (b + c) = a * b + a * c`."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Multiplication is distributive over addition on the left.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$a(b + c) = ab + ac$."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "You can do induction on any of the three variables. Some choices\n"
"are harder to push through than others. Can you do the inductive step in\n"
"5 rewrites only?"
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Induction on `a` is the most troublesome, then `b`,\n"
"and `c` is the easiest."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Here's my solution:\n"
"```\n"
"induction c with d hd\n"
"rw [add_zero, mul_zero, add_zero]\n"
"rfl\n"
"rw [add_succ, mul_succ, hd, mul_succ, add_assoc]\n"
"rfl\n"
"```\n"
"\n"
"Inducting on `a` or `b` also works, but might take longer."
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "add_mul"
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "`add_mul` is just as fiddly to prove by induction; but there's a trick\n"
"which avoids it. Can you spot it?"
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "`add_mul a b c` is a proof that $(a+b)c=ac+bc$."
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "Addition is distributive over multiplication.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(a + b) \\times c = ac + bc$."
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "Here's my proof:\n"
"```\n"
"rw [mul_comm, mul_add]\n"
"repeat rw [mul_comm c]\n"
"rfl\n"
"```"
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "mul_assoc"
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "We now have enough to prove that multiplication is associative,\n"
"the boss level of multiplication world. Good luck!"
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "`mul_assoc a b c` is a proof that `(a * b) * c = a * (b * c)`.\n"
"\n"
"Note that when Lean says `a * b * c` it means `(a * b) * c`.\n"
"\n"
"Note that `(a * b) * c = a * (b * c)` cannot be proved by \\\"pure thought\\\":\n"
"for example subtraction is not associative, as `(6 - 2) - 1` is not\n"
"equal to `6 - (2 - 1)`."
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "Multiplication is associative.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(ab)c = a(bc)$."
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "A passing mathematician notes that you've proved\n"
"that the natural numbers are a commutative semiring.\n"
"\n"
"If you want to begin your journey to the final boss, head for Power World."
msgstr ""

#: Game.Levels.Multiplication
msgid "Multiplication World"
msgstr ""

#: Game.Levels.Multiplication
msgid "How should we define `37 * x`? Just like addition, we need to give definitions\n"
"when $x=0$ and when $x$ is a successor.\n"
"\n"
"The zero case is easy: we define `37 * 0` to be `0`. Now say we know\n"
"`37 * d`. What should `37 * succ d` be? Well, that's $(d+1)$ $37$s,\n"
"so it should be `37 * d + 37`.\n"
"\n"
"Here are the definitions in Lean.\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"  * `mul_succ a d : a * succ d = a * d + a`\n"
"\n"
"In this world, we must not only prove facts about multiplication like `a * b = b * a`,\n"
"we must also prove facts about how multiplication interacts with addition, like `a * (b + c) = a * b + a * c`.\n"
"Let's get started."
msgstr ""

#: Game.Levels.Implication.L01_exact_I
msgid "The `exact` tactic"
msgstr ""

#: Game.Levels.Implication.L01_exact_I
msgid "## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will close the goal if `h` is a proof of `P`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x = 37` and you have a hypothesis `h : x = 37`\n"
"then `exact h` will solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x + 0 = x` then `exact add_zero x` will close the goal.\n"
"\n"
"### Exact needs to be exactly right\n"
"\n"
"Note that `exact add_zero` will *not work* in the previous example;\n"
"for `exact h` to work, `h` has to be *exactly* a proof of the goal.\n"
"`add_zero` is a proof of `‚àÄ n, n + 0 = n` or, if you like,\n"
"a proof of `? + 0 = ?` where `?` needs to be supplied by the user.\n"
"This is in contrast to `rw` and `apply`, which will \\\"guess the inputs\\\"\n"
"if necessary. If the goal is `x + 0 = x` then `rw [add_zero]`\n"
"and `rw [add_zero x]` will both change the goal to `x = x`,\n"
"because `rw` guesses the input to the function `add_zero`."
msgstr ""

#: Game.Levels.Implication.L01_exact_I
msgid "In this world we'll learn how to prove theorems of the form $P\\implies Q$.\n"
"In other words, how to prove theorems of the form \"if $P$ is true, then $Q$ is true.\"\n"
"To do that we need to learn some more tactics.\n"
"\n"
"The `exact` tactic can be used to close a goal which is exactly one of\n"
"the hypotheses. It takes the name of the hypothesis as argument: `exact h`."
msgstr ""

#: Game.Levels.Implication.L01_exact_I
msgid "Assuming $x+y=37$ and $3x+z=42$, we have $x+y=37$."
msgstr ""

#: Game.Levels.Implication.L01_exact_I
msgid "The goal in this level is one of our hypotheses. Solve the goal by executing `exact h1`."
msgstr ""

#: Game.Levels.Implication.L02_exact_II
msgid "`exact` practice."
msgstr ""

#: Game.Levels.Implication.L02_exact_II
msgid "If the goal is not *exactly* a hypothesis, we can sometimes\n"
"use rewrites to fix things up."
msgstr ""

#: Game.Levels.Implication.L02_exact_II
msgid "Assuming $0+x=(0+y)+2$, we have $x=y+2$."
msgstr ""

#: Game.Levels.Implication.L02_exact_II
msgid "You can use `rw [zero_add] at ¬´{h}¬ª` to rewrite at `¬´{h}¬ª` instead\n"
"of at the goal."
msgstr ""

#: Game.Levels.Implication.L02_exact_II
msgid "Do that again!\n"
"\n"
"`rw [zero_add] at ¬´{h}¬ª` tries to fill in\n"
"the arguments to `zero_add` (finding `¬´{x}¬ª`) then it replaces all occurences of\n"
"`0 + ¬´{x}¬ª` it finds. Therefor, it did not rewrite `0 + ¬´{y}¬ª`, yet."
msgstr ""

#: Game.Levels.Implication.L02_exact_II
msgid "Now you could finish with `rw [¬´{h}¬ª]` then `rfl`, but `exact ¬´{h}¬ª`\n"
"does it in one line."
msgstr ""

#: Game.Levels.Implication.L02_exact_II
msgid "Here's a two-line proof:\n"
"```\n"
"repeat rw [zero_add] at h\n"
"exact h\n"
"```"
msgstr ""

#: Game.Levels.Implication.L03_apply
msgid "The `apply` tactic."
msgstr ""

#: Game.Levels.Implication.L03_apply
msgid "## Summary\n"
"\n"
"If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"If the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\n"
"goal to `P`. The idea here is that if you want to prove `Q`, then by `t`\n"
"it suffices to prove `P`, so you can reduce the goal to proving `P`.\n"
"\n"
"### Example:\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y ‚Üí x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""

#: Game.Levels.Implication.L03_apply
msgid "In this level one of our hypotheses is an *implication*. We can use this\n"
"hypothesis with the `apply` tactic."
msgstr ""

#: Game.Levels.Implication.L03_apply
msgid "If $x=37$ and we know that $x=37\\implies y=42$ then we can deduce $y=42$."
msgstr ""

#: Game.Levels.Implication.L03_apply
msgid "Start with `apply h2 at h1`. This will change `h1` to `y = 42`."
msgstr ""

#: Game.Levels.Implication.L03_apply
msgid "Now finish using the `exact` tactic."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "succ_inj : the successor function is injective"
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "If `a` and `b` are numbers, then `succ_inj a b` is a proof\n"
"that `succ a = succ b` implies `a = b`. Click on this theorem in the *Peano*\n"
"tab for more information.\n"
"\n"
"Peano had this theorem as an axiom, but in Algorithm World\n"
"we will show how to prove it in Lean. Right now let's just assume it,\n"
"and let's prove $x+1=4 \\implies x=3$ using it. Again, we will proceed\n"
"by manipulating our hypothesis until it becomes the goal. I will\n"
"walk you through this level."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "# Statement\n"
"\n"
"If $a$ and $b$ are numbers, then\n"
"`succ_inj a b` is the proof that\n"
"$ (\\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"## More technical details\n"
"\n"
"There are other ways to think about `succ_inj`.\n"
"\n"
"You can think about `succ_inj` itself as a function which takes two\n"
"numbers $$a$$ and $$b$$ as input, and outputs a proof of\n"
"$ ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"You can think of `succ_inj` itself as a proof; it is the proof\n"
"that `succ` is an injective function. In other words,\n"
"`succ_inj` is a proof of\n"
"$\\forall a, b \\in  \\mathbb{N}, ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"`succ_inj` was postulated as an axiom by Peano, but\n"
"in Lean it can be proved using `pred`, a mathematically\n"
"pathological function."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "If $x+1=4$ then $x=3$."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "Let's first get `h` into the form `succ x = succ 3` so we can\n"
"apply `succ_inj`. First execute `rw [four_eq_succ_three] at h`\n"
"to change the 4 on the right hand side."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "Now rewrite `succ_eq_add_one` backwards at `h`\n"
"to get the right hand side."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "You can put a `‚Üê` in front of any theorem provided to `rw` to rewrite\n"
"the other way around. Look at the docs for `rw` for an explanation. Type `‚Üê` with `\\l`."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "Concretely: `rw [‚Üê succ_eq_add_one] at h`."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "Now let's `apply` our new theorem. Execute `apply succ_inj at h`\n"
"to change `h` to a proof of `x = 3`."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "Now finish in one line."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "And now we've deduced what we wanted to prove: the goal is one of our assumptions.\n"
"Finish the level with `exact h`."
msgstr ""

#: Game.Levels.Implication.L04_succinj_I
msgid "In the next level, we'll do the same proof but backwards."
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "Arguing backwards"
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "In the last level, we manipulated the hypothesis `x + 1 = 4`\n"
"  until it became the goal `x = 3`. In this level we'll manipulate\n"
"  the goal until it becomes our hypothesis! In other words, we\n"
"  will \"argue backwards\". The `apply` tactic can do this too.\n"
"  Again I will walk you through this one (assuming you're in\n"
"  command line mode)."
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "If $x+1=4$ then $x=3$."
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "Start with `apply succ_inj` to apply `succ_inj` to the *goal*."
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "Applying a proof of $P\\implies Q$ to the *goal* changes $Q$ to $P$.\n"
"Now try `rw [succ_eq_add_one]` to make the goal more like the hypothesis."
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "Now rewrite `four_eq_succ_three` backwards to make the goal\n"
"equal to the hypothesis."
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "You can now finish with `exact h`."
msgstr ""

#: Game.Levels.Implication.L05_succinj_II
msgid "Many people find `apply t at h` easy, but some find `apply t` confusing.\n"
"If you find it confusing, then just argue forwards.\n"
"\n"
"You can read more about the `apply` tactic in its documentation, which you can view by\n"
"clicking on the tactic in the list on the right."
msgstr ""

#: Game.Levels.Implication.L06_intro_I
msgid "intro"
msgstr ""

#: Game.Levels.Implication.L06_intro_I
msgid "## Summary\n"
"\n"
"If the goal is `P ‚Üí Q`, then `intro h` will introduce `h : P` as a hypothesis,\n"
"and change the goal to `Q`. Mathematically, it says that to prove $P \\implies Q$,\n"
"we can assume $P$ and then prove $Q$.\n"
"\n"
"### Example:\n"
"\n"
"If your goal is `x + 1 = y + 1 ‚Üí x = y` (the way Lean writes $x+1=y+1 \\implies x=y$)\n"
"then `intro h` will give you a hypothesis $x+1=y+1$ named `h`, and the goal\n"
"will change to $x=y$."
msgstr ""

#: Game.Levels.Implication.L06_intro_I
msgid "We have seen how to `apply` theorems and assumptions\n"
"of the form `P ‚Üí Q`. But what if our *goal* is of the form `P ‚Üí Q`?\n"
"To prove this goal, we need to know how to say \"let's assume `P` and deduce `Q`\"\n"
"in Lean. We do this with the `intro` tactic."
msgstr ""

#: Game.Levels.Implication.L06_intro_I
msgid "$x=37\\implies x=37$."
msgstr ""

#: Game.Levels.Implication.L06_intro_I
msgid "Start with `intro h` to assume the hypothesis and call its proof `h`."
msgstr ""

#: Game.Levels.Implication.L06_intro_I
msgid "Now `exact h` finishes the job."
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "intro practice"
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "Let's see if you can use the tactics we've learnt to prove $x+1=y+1\\implies x=y$.\n"
"Try this one by yourself; if you need help then click on \"Show more help!\"."
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "$x+1=y+1 \\implies x=y$."
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "Start with `intro h` to assume the hypothesis."
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "Now `repeat rw [‚Üê succ_eq_add_one] at h` is the quickest way to\n"
"change `succ x = succ y`."
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "Now `apply succ_inj at h` to cancel the `succ`s."
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "Now `rw [h]` then `rfl` works, but `exact h` is quicker."
msgstr ""

#: Game.Levels.Implication.L07_intro_II
msgid "Here's a completely backwards proof:\n"
"```\n"
"intro h\n"
"apply succ_inj\n"
"repeat rw [succ_eq_add_one]\n"
"exact h\n"
"```"
msgstr ""

#: Game.Levels.Implication.L08_ne
msgid "‚â†"
msgstr ""

#: Game.Levels.Implication.L08_ne
msgid "We still can't prove `2 + 2 ‚â† 5` because we have not talked about the\n"
"definition of `‚â†`. In Lean, `a ‚â† b` is *notation* for `a = b ‚Üí False`.\n"
"Here `False` is a generic false proposition, and `‚Üí` is Lean's notation\n"
"for \"implies\". In logic we learn\n"
"that `True ‚Üí False` is false, but `False ‚Üí False` is true. Hence\n"
"`X ‚Üí False` is the logical opposite of `X`.\n"
"\n"
"Even though `a ‚â† b` does not look like an implication,\n"
"you should treat it as an implication. The next two levels will show you how.\n"
"\n"
"`False` is a goal which you cannot deduce from a consistent set of assumptions!\n"
"So if your goal is `False` then you had better hope that your hypotheses\n"
"are contradictory, which they are in this level."
msgstr ""

#: Game.Levels.Implication.L08_ne
msgid "If $x=y$ and $x \\neq y$ then we can deduce a contradiction."
msgstr ""

#: Game.Levels.Implication.L08_ne
msgid "Remember that `h2` is a proof of `x = y ‚Üí False`. Try\n"
"`apply`ing `h2` either `at h1` or directly to the goal."
msgstr ""

#: Game.Levels.Implication.L08_ne
msgid "`a ‚â† b` is *notation* for `(a = b) ‚Üí False`.\n"
"\n"
"The reason this is mathematically\n"
"valid is that if `P` is a true-false statement then `P ‚Üí False`\n"
"is the logical opposite of `P`. Indeed `True ‚Üí False` is false,\n"
"and `False ‚Üí False` is true!\n"
"\n"
"The upshot of this is that you can treat `a ‚â† b` in exactly\n"
"the same way as you treat any implication `P ‚Üí Q`. For example,\n"
"if your *goal* is of the form `a ‚â† b` then you can make progress\n"
"with `intro h`, and if you have a hypothesis `h` of the\n"
"form `a ‚â† b` then you can `apply h at h1` if `h1` is a proof\n"
"of `a = b`."
msgstr ""

#: Game.Levels.Implication.L08_ne
msgid "Remember, `x ‚â† y` is *notation* for `x = y ‚Üí False`."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "zero_ne_succ"
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "`zero_ne_succ n` is the proof that `0 ‚â† succ n`.\n"
"\n"
"In Lean, `a ‚â† b` is *defined to mean* `a = b ‚Üí False`. Hence\n"
"`zero_ne_succ n` is really a proof of `0 = succ n ‚Üí False`.\n"
"Here `False` is a generic false statement. This means that\n"
"you can `apply zero_ne_succ at h` if `h` is a proof of `0 = succ n`."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "As warm-up for `2 + 2 ‚â† 5` let's prove `0 ‚â† 1`. To do this we need to\n"
"introduce Peano's last axiom `zero_ne_succ n`, a proof that `0 ‚â† succ n`.\n"
"To learn about this result, click on it in the list of lemmas on the right."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "`zero_ne_one` is a proof of `0 ‚â† 1`."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "$0\\neq1$."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "Start with `intro h`."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "Now change `1` to `succ 0` in `h`."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "Now you can `apply zero_ne_succ at h`."
msgstr ""

#: Game.Levels.Implication.L09_zeronesucc
msgid "Nice!"
msgstr ""

#: Game.Levels.Implication.L10_zeroneone
msgid "1 ‚â† 0"
msgstr ""

#: Game.Levels.Implication.L10_zeroneone
msgid "We know `zero_ne_succ n` is a proof of `0 = succ n ‚Üí False` -- but what\n"
"if we have a hypothesis `succ n = 0`? It's the wrong way around!\n"
"\n"
"The `symm` tactic changes a goal `x = y` to `y = x`, and a goal `x ‚â† y`\n"
"to `y ‚â† x`. And `symm at h`\n"
"does the same for a hypothesis `h`. We've proved $0 \\neq 1$ and called\n"
"the proof `zero_ne_one`; now try proving $1 \\neq 0$."
msgstr ""

#: Game.Levels.Implication.L10_zeroneone
msgid "## Summary\n"
"\n"
"The `symm` tactic will change a goal or hypothesis of\n"
"the form `X = Y` to `Y = X`. It will also work on `X ‚â† Y`\n"
"and on `X ‚Üî Y`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `symm` will change it to `4 = 2 + 2`.\n"
"\n"
"### Example\n"
"\n"
"If `h : 2 + 2 ‚â† 5` then `symm at h` will change `h` to `5 ‚â† 2 + 2`."
msgstr ""

#: Game.Levels.Implication.L10_zeroneone
msgid "`one_ne_zero` is a proof that `1 ‚â† 0`."
msgstr ""

#: Game.Levels.Implication.L10_zeroneone
msgid "$1\\neq0$."
msgstr ""

#: Game.Levels.Implication.L10_zeroneone
msgid "What do you think of this two-liner:\n"
"```\n"
"symm\n"
"exact zero_ne_one\n"
"```\n"
"\n"
"`exact` doesn't just take hypotheses, it will eat any proof which exists\n"
"in the system."
msgstr ""

#: Game.Levels.Implication.L11_neV
msgid "2 + 2 ‚â† 5"
msgstr ""

#: Game.Levels.Implication.L11_neV
msgid "2 + 2 ‚â† 5 is boring to prove in full, given only the tools we have currently.\n"
"To make it a bit less painful, I have unfolded all of the numerals for you.\n"
"See if you can use `zero_ne_succ` and `succ_inj` to prove this."
msgstr ""

#: Game.Levels.Implication.L11_neV
msgid "$2+2‚â†5$."
msgstr ""

#: Game.Levels.Implication.L11_neV
msgid "Here's my proof:\n"
"```\n"
"intro h\n"
"rw [add_succ, add_succ, add_zero] at h\n"
"repeat apply succ_inj at h\n"
"apply zero_ne_succ at h\n"
"exact h\n"
"```\n"
"\n"
"Even though Lean is a theorem prover, right now it's pretty clear that we have not\n"
"developed enough material to make it an adequate calculator. In Algorithm\n"
"World, a more computer-sciency world, we will develop machinery which makes\n"
"questions like this much easier, and goals like $20 + 20 ‚â† 41$ feasible.\n"
"Alternatively you can do more mathematics in Advanced Addition World, where we prove\n"
"the lemmas needed to get a working theory of inequalities. Click \"Leave World\" and\n"
"decide your route."
msgstr ""

#: Game.Levels.Implication
msgid "Implication World"
msgstr ""

#: Game.Levels.Implication
msgid "We've proved that $2+2=4$; in Implication World we'll learn\n"
"how to prove $2+2\\neq 5$.\n"
"\n"
"In Addition World we proved *equalities* like $x + y = y + x$.\n"
"In this second tutorial world we'll learn some new tactics,\n"
"enabling us to prove *implications*\n"
"like $x+1=4 \\implies x=3.$\n"
"\n"
"We'll also learn two new fundamental facts about\n"
"natural numbers, which Peano introduced as axioms.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""

#: Game.Levels.Power.L01_zeropown_I
msgid "zero_pow_zero"
msgstr ""

#: Game.Levels.Power.L01_zeropown_I
msgid "Mathematicians sometimes debate what `0 ^ 0` is;\n"
"the answer depends, of course, on your definitions. In this\n"
"game, `0 ^ 0 = 1`. See if you can prove it.\n"
"\n"
"Check out the *Pow* tab in your list of theorems\n"
"to see the new proofs which are available."
msgstr ""

#: Game.Levels.Power.L01_zeropown_I
msgid "`Pow a b`, with notation `a ^ b`, is the usual\n"
"  exponentiation of natural numbers. Internally it is\n"
"  defined via two axioms:\n"
"\n"
"  * `pow_zero a : a ^ 0 = 1`\n"
"\n"
"  * `pow_succ a b : a ^ succ b = a ^ b * a`\n"
"\n"
"Note in particular that `0 ^ 0 = 1`."
msgstr ""

#: Game.Levels.Power.L01_zeropown_I
msgid "`pow_zero a : a ^ 0 = 1` is one of the two axioms\n"
"defining exponentiation in this game."
msgstr ""

#: Game.Levels.Power.L01_zeropown_I
msgid "Mathematicians sometimes argue that `0 ^ 0 = 0` is also\n"
"a good convention. But it is not a good convention in this\n"
"game; all the later levels come out beautifully with the\n"
"convention that `0 ^ 0 = 1`."
msgstr ""

#: Game.Levels.Power.L01_zeropown_I
msgid "$0 ^ 0 = 1$"
msgstr ""

#: Game.Levels.Power.L02_zeropown_II
msgid "zero_pow_succ"
msgstr ""

#: Game.Levels.Power.L02_zeropown_II
msgid "We've just seen that `0 ^ 0 = 1`, but if `n`\n"
"is a successor, then `0 ^ n = 0`. We prove that here."
msgstr ""

#: Game.Levels.Power.L02_zeropown_II
msgid "`pow_succ a b : a ^ (succ b) = a ^ b * a` is one of the\n"
"two axioms defining exponentiation in this game."
msgstr ""

#: Game.Levels.Power.L02_zeropown_II
msgid "Although $0^0=1$ in this game, $0^n=0$ if $n>0$, i.e., if\n"
"$n$ is a successor."
msgstr ""

#: Game.Levels.Power.L02_zeropown_II
msgid "For all numbers $m$, $0 ^{\\operatorname{succ} (m)} = 0$."
msgstr ""

#: Game.Levels.Power.L03_powone
msgid "pow_one"
msgstr ""

#: Game.Levels.Power.L03_powone
msgid "`pow_one a` says that `a ^ 1 = a`.\n"
"\n"
"Note that this is not quite true by definition: `a ^ 1` is\n"
"defined to be `a ^ 0 * a` so it's `1 * a`, and to prove\n"
"that this is equal to `a` you need to use induction somewhere."
msgstr ""

#: Game.Levels.Power.L03_powone
msgid "For all naturals $a$, $a ^ 1 = a$."
msgstr ""

#: Game.Levels.Power.L04_onepow
msgid "one_pow"
msgstr ""

#: Game.Levels.Power.L04_onepow
msgid "`one_pow n` is a proof that $1^n=1$."
msgstr ""

#: Game.Levels.Power.L04_onepow
msgid "For all naturals $m$, $1 ^ m = 1$."
msgstr ""

#: Game.Levels.Power.L05_powtwo
msgid "pow_two"
msgstr ""

#: Game.Levels.Power.L05_powtwo
msgid "Note: this lemma will be useful for the final boss!"
msgstr ""

#: Game.Levels.Power.L05_powtwo
msgid "`pow_two a` says that `a ^ 2 = a * a`."
msgstr ""

#: Game.Levels.Power.L05_powtwo
msgid "For all naturals $a$, $a ^ 2 = a \\times a$."
msgstr ""

#: Game.Levels.Power.L06_powadd
msgid "pow_add"
msgstr ""

#: Game.Levels.Power.L06_powadd
msgid "Let's now begin our approach to the final boss,\n"
"by proving some more subtle facts about powers."
msgstr ""

#: Game.Levels.Power.L06_powadd
msgid "`pow_add a m n` is a proof that $a^{m+n}=a^ma^n.$"
msgstr ""

#: Game.Levels.Power.L06_powadd
msgid "For all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$."
msgstr ""

#: Game.Levels.Power.L07_mulpow
msgid "mul_pow"
msgstr ""

#: Game.Levels.Power.L07_mulpow
msgid "The music gets ever more dramatic, as we explore\n"
"the interplay between exponentiation and multiplication.\n"
"\n"
"If you're having trouble exchanging the right `a * b`\n"
"because `rw [mul_comm]` swaps the wrong multiplication,\n"
"then read the documentation of `rw` for tips on how to fix this."
msgstr ""

#: Game.Levels.Power.L07_mulpow
msgid "`mul_pow a b n` is a proof that $(ab)^n=a^nb^n.$"
msgstr ""

#: Game.Levels.Power.L07_mulpow
msgid "For all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$."
msgstr ""

#: Game.Levels.Power.L08_powpow
msgid "pow_pow"
msgstr ""

#: Game.Levels.Power.L08_powpow
msgid "One of the best named levels in the game, a savage `pow_pow`\n"
"sub-boss appears as the music reaches a frenzy. What\n"
"else could there be to prove about powers after this?"
msgstr ""

#: Game.Levels.Power.L08_powpow
msgid "`pow_pow a m n` is a proof that $(a^m)^n=a^{mn}.$"
msgstr ""

#: Game.Levels.Power.L08_powpow
msgid "For all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$."
msgstr ""

#: Game.Levels.Power.L08_powpow
msgid "The music dies down. Is that it?\n"
"\n"
"Course it isn't, you can\n"
"clearly see that there are two levels left.\n"
"\n"
"A passing mathematician says that mathematicians don't have a name\n"
"for the structure you just constructed. You feel cheated.\n"
"\n"
"Suddenly the music starts up again. This really is the final boss."
msgstr ""

#: Game.Levels.Power.L09_addsq
msgid "add_sq"
msgstr ""

#: Game.Levels.Power.L09_addsq
msgid "[final boss music]"
msgstr ""

#: Game.Levels.Power.L09_addsq
msgid "`add_sq a b` is the statement that $(a+b)^2=a^2+b^2+2ab.$"
msgstr ""

#: Game.Levels.Power.L09_addsq
msgid "For all numbers $a$ and $b$, we have\n"
"$$(a+b)^2=a^2+b^2+2ab.$$"
msgstr ""

#: Game.Levels.Power.L09_addsq
msgid "It's all over! You have proved a theorem which has tripped up\n"
"schoolkids for generations (some of them think $(a+b)^2=a^2+b^2$:\n"
"this is \"the freshman's dream\").\n"
"\n"
"How many rewrites did you use? I can do it in 12.\n"
"\n"
"But wait! This boss is stirring...and mutating into a second more powerful form!"
msgstr ""

#: Game.Levels.Power.L10_FLT
msgid "Fermat's Last Theorem"
msgstr ""

#: Game.Levels.Power.L10_FLT
msgid "We now have enough to state a mathematically accurate, but slightly\n"
"clunky, version of Fermat's Last Theorem.\n"
"\n"
"Fermat's Last Theorem states that if $x,y,z>0$ and $m \\geq 3$ then $x^m+y^m\\not =z^m$.\n"
"If you didn't do inequality world yet then we can't talk about $m \\geq 3$,\n"
"so we have to resort to the hack of using `n + 3` for `m`,\n"
"which guarantees it's big enough. Similarly instead of `x > 0` we\n"
"use `a + 1`.\n"
"\n"
"This level looks superficially like other levels we have seen,\n"
"but the shortest solution known to humans would translate into\n"
"many millions of lines of Lean code. The author of this game,\n"
"Kevin Buzzard, is working on translating the proof by Wiles\n"
"and Taylor into Lean, although this task will take many years.\n"
"\n"
"## CONGRATULATIONS!\n"
"\n"
"You've finished the main quest of the natural number game!\n"
"If you would like to learn more about how to use Lean to\n"
"prove theorems in mathematics, then take a look\n"
"at [Mathematics In Lean](https://leanprover-community.github.io/mathematics_in_lean/),\n"
"an interactive textbook which you can read in your browser,\n"
"and which explains how to work with many more mathematical concepts in Lean."
msgstr ""

#: Game.Levels.Power.L10_FLT
msgid "`xyzzy` is an ancient magic spell, believed to be the origin of the\n"
"modern word `sorry`. The game won't complain - or notice - if you\n"
"prove anything with `xyzzy`."
msgstr ""

#: Game.Levels.Power.L10_FLT
msgid "For all naturals $a$ $b$ $c$ and $n$, we have\n"
"$$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$"
msgstr ""

#: Game.Levels.Power.L10_FLT
msgid "Congratulations! You have proved Fermat's Last Theorem!\n"
"\n"
"Either that, or you used magic..."
msgstr ""

#: Game.Levels.Power
msgid "Power World"
msgstr ""

#: Game.Levels.Power
msgid "This world introduces exponentiation. If you want to define `37 ^ n`\n"
"then, as always, you will need to know what `37 ^ 0` is, and\n"
"what `37 ^ (succ d)` is, given only `37 ^ d`.\n"
"\n"
"You can probably guess the names of the general theorems:\n"
"\n"
"  * `pow_zero (a : ‚Ñï) : a ^ 0 = 1`\n"
"  * `pow_succ (a b : ‚Ñï) : a ^ succ b = a ^ b * a`\n"
"\n"
"Using only these, can you get past the final boss level?\n"
"\n"
"The levels in this world were designed by Sian Carey, a UROP student\n"
"at Imperial College London, funded by a Mary Lister McCammon Fellowship\n"
"in the summer of 2019. Thanks to Sian and also thanks to Imperial\n"
"College for funding her."
msgstr ""

#: Game.Levels.Algorithm.L01_ladcomm
msgid "add_left_comm"
msgstr ""

#: Game.Levels.Algorithm.L01_ladcomm
msgid "`add_left_comm a b c` is a proof that `a + (b + c) = b + (a + c)`."
msgstr ""

#: Game.Levels.Algorithm.L01_ladcomm
msgid "Having to rearrange variables manually using commutativity and\n"
"associativity is very tedious. We start by reminding you of this. `add_left_comm`\n"
"is a key component in the first algorithm which we'll explain, but we need\n"
"to prove it manually.\n"
"\n"
"Remember that you can do precision commutativity rewriting\n"
"with things like `rw [add_comm b c]`. And remember that\n"
"`a + b + c` means `(a + b) + c`."
msgstr ""

#: Game.Levels.Algorithm.L01_ladcomm
msgid "If $a, b, c$ are numbers, then $a+(b+c)=b+(a+c)$."
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "making life easier"
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "In some later worlds, we're going to see some much nastier levels,\n"
"like `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + b + 1)`.\n"
"Brackets need to be moved around, and variables need to be swapped.\n"
"\n"
"In this level, `(a + b) + (c + d) = ((a + c) + d) + b`,\n"
"let's forget about the brackets and just think about\n"
"the variable order.\n"
"To turn `a+b+c+d` into `a+c+d+b` we need to swap `b` and `c`,\n"
"and then swap `b` and `d`. But this is easier than you\n"
"think with `add_left_comm`."
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "If $a, b$, $c$ and $d$ are numbers, we have\n"
"$(a + b) + (c + d) = ((a + c) + d) + b.$"
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "Start with `repeat rw [add_assoc]` to push all the brackets to the right."
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "Now use `rw [add_left_comm b c]` to switch `b` and `c` on the left\n"
"hand side."
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "Finally use a targetted `add_comm` to switch `b` and `d`"
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "`rw [add_comm b d]`."
msgstr ""

#: Game.Levels.Algorithm.L02_addalgo_I
msgid "So that's the algorithm: now let's use automation to perform it\n"
"automatically."
msgstr ""

#: Game.Levels.Algorithm.L03_addalgo_II
msgid "making life simple"
msgstr ""

#: Game.Levels.Algorithm.L03_addalgo_II
msgid "# Overview\n"
"\n"
"Lean's simplifier, `simp`, will rewrite every lemma\n"
"tagged with `simp` and every lemma fed to it by the user, as much as it can.\n"
"Furthermore, it will attempt to order variables into an internal order if fed\n"
"lemmas such as `add_comm`, so that it does not go into an infinite loop."
msgstr ""

#: Game.Levels.Algorithm.L03_addalgo_II
msgid "Lean's simplifier, `simp`, is \"`rw` on steroids\". It will rewrite every lemma\n"
"tagged with `simp` and every lemma fed to it by the user, as much as it can.\n"
"\n"
"This level is not a level which you want to solve by hand.\n"
"Get the simplifier to solve it for you."
msgstr ""

#: Game.Levels.Algorithm.L03_addalgo_II
msgid "If $a, b,\\ldots h$ are arbitrary natural numbers, we have\n"
"$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$."
msgstr ""

#: Game.Levels.Algorithm.L03_addalgo_II
msgid "Solve this level in one line with `simp only [add_assoc, add_left_comm, add_comm]`"
msgstr ""

#: Game.Levels.Algorithm.L03_addalgo_II
msgid "Let's now make our own tactic to do this."
msgstr ""

#: Game.Levels.Algorithm.L04_addalgo_III
msgid "the simplest approach"
msgstr ""

#: Game.Levels.Algorithm.L04_addalgo_III
msgid "# Overview\n"
"\n"
"Our home-made tactic `simp_add` will solve arbitrary goals of\n"
"the form `a + (b + c) + (d + e) = e + (d + (c + b)) + a`."
msgstr ""

#: Game.Levels.Algorithm.L04_addalgo_III
msgid "You can make your own tactics in Lean.\n"
"This code here\n"
"```\n"
"macro \"simp_add\" : tactic => `(tactic|(\n"
"  simp only [add_assoc, add_left_comm, add_comm]))\n"
"```\n"
"was used to create a new tactic `simp_add`, which runs\n"
"`simp only [add_assoc, add_left_comm, add_comm]`.\n"
"Try running `simp_add` to solve this level!"
msgstr ""

#: Game.Levels.Algorithm.L04_addalgo_III
msgid "If $a, b,\\ldots h$ are arbitrary natural numbers, we have\n"
"$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$."
msgstr ""

#: Game.Levels.Algorithm.L04_addalgo_III
msgid "Let's now move on to a more efficient approach to questions\n"
"involving numerals, such as `20 + 20 = 40`."
msgstr ""

#: Game.Levels.Algorithm.L05_pred
msgid "pred"
msgstr ""

#: Game.Levels.Algorithm.L05_pred
msgid "We now start work on an algorithm to do addition more efficiently. Recall that\n"
"we defined addition by recursion, saying what it did on `0` and successors.\n"
"It is an axiom of Lean that recursion is a valid\n"
"way to define functions from types such as the naturals.\n"
"\n"
"Let's define a new function `pred` from the naturals to the naturals, which\n"
"attempts to subtract 1 from the input. The definition is this:\n"
"\n"
"```\n"
"pred 0 := 37\n"
"pred (succ n) := n\n"
"```\n"
"\n"
"We cannot subtract one from 0, so we just return a junk value. As well as this\n"
"definition, we also create a new lemma `pred_succ`, which says that `pred (succ n) = n`.\n"
"Let's use this lemma to prove `succ_inj`, the theorem which\n"
"Peano assumed as an axiom and which we have already used extensively without justification."
msgstr ""

#: Game.Levels.Algorithm.L05_pred
msgid "`pred_succ n` is a proof of `pred (succ n) = n`."
msgstr ""

#: Game.Levels.Algorithm.L05_pred
msgid "If $\\operatorname{succ}(a)=\\operatorname{succ}(b)$ then $a=b$."
msgstr ""

#: Game.Levels.Algorithm.L05_pred
msgid "Start with `rw [‚Üê pred_succ a]` and take it from there."
msgstr ""

#: Game.Levels.Algorithm.L05_pred
msgid "Nice! You've proved `succ_inj`!\n"
"Let's now prove Peano's other axiom, that successors can't be $0$."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "is_zero"
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "We define a function `is_zero` thus:\n"
"\n"
"```\n"
"is_zero 0 := True\n"
"is_zero (succ n) := False\n"
"```\n"
"\n"
"We also create two lemmas, `is_zero_zero` and `is_zero_succ n`, saying that `is_zero 0 = True`\n"
"and `is_zero (succ n) = False`. Let's use these lemmas to prove `succ_ne_zero`, Peano's\n"
"Last Axiom. Actually, we have been using `zero_ne_succ` before, but it's handy to have\n"
"this opposite version too, which can be proved in the same way. Note: you can\n"
"cheat here by using `zero_ne_succ` but the point of this world is to show\n"
"you how to *prove* results like that.\n"
"\n"
"If you can turn your goal into `True`, then the `trivial` tactic will solve it."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "`is_zero_zero` is a proof of `is_zero 0 = True`."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "`is_zero_succ a` is a proof of `is_zero (succ a) = False`."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "`succ_ne_zero a` is a proof of `succ a ‚â† 0`."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "# Summary\n"
"\n"
"`trivial` will solve the goal `True`."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "$\\operatorname{succ}(a) \\neq 0$."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "Start with `intro h` (remembering that `X ‚â† Y` is just notation\n"
"for `X = Y ‚Üí False`)."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "We're going to change that `False` into `True`. Start by changing it into\n"
"`is_zero (succ a)` by executing `rw [‚Üê is_zero_succ a]`."
msgstr ""

#: Game.Levels.Algorithm.L06_iszero
msgid "See if you can take it from here. Look at the new lemmas and tactic\n"
"available on the right."
msgstr ""

#: Game.Levels.Algorithm.L07_succnesucc
msgid "An algorithm for equality"
msgstr ""

#: Game.Levels.Algorithm.L07_succnesucc
msgid "Here we begin to\n"
"develop an algorithm which, given two naturals `a` and `b`, returns the answer\n"
"to \"does `a = b`?\"\n"
"\n"
"Here is the algorithm. First note that `a` and `b` are numbers, and hence\n"
"are either `0` or successors.\n"
"\n"
"*) If `a` and `b` are both `0`, return \"yes\".\n"
"\n"
"*) If one is `0` and the other is `succ n`, return \"no\".\n"
"\n"
"*) If `a = succ m` and `b = succ n`, then return the answer to \"does `m = n`?\"\n"
"\n"
"Our job now is to *prove* that this algorithm always gives the correct answer. The proof that\n"
"`0 = 0` is `rfl`. The proof that `0 ‚â† succ n` is `zero_ne_succ n`, and the proof\n"
"that `succ m ‚â† 0` is `succ_ne_zero m`. The proof that if `h : m = n` then\n"
"`succ m = succ n` is `rw [h]` and then `rfl`. This level is a proof of the one\n"
"remaining job we have to do: if `a ‚â† b` then `succ a ‚â† succ b`."
msgstr ""

#: Game.Levels.Algorithm.L07_succnesucc
msgid "# Summary\n"
"\n"
"If you have a hypothesis\n"
"\n"
"`h : a ‚â† b`\n"
"\n"
"and goal\n"
"\n"
"`c ‚â† d`\n"
"\n"
"then `contrapose! h` replaces the set-up with its so-called \\\"contrapositive\\\":\n"
"a hypothesis\n"
"\n"
"`h : c = d`\n"
"\n"
"and goal\n"
"\n"
"`a = b`."
msgstr ""

#: Game.Levels.Algorithm.L07_succnesucc
msgid "`succ_ne_succ m n` is the proof that `m ‚â† n ‚Üí succ m ‚â† succ n`."
msgstr ""

#: Game.Levels.Algorithm.L07_succnesucc
msgid "If $a \\neq b$ then $\\operatorname{succ}(a) \\neq\\operatorname{succ}(b)$."
msgstr ""

#: Game.Levels.Algorithm.L07_succnesucc
msgid "Start with `contrapose! h`, to change the goal into its\n"
"contrapositive, namely a hypothesis of `succ m = succ m` and a goal of `m = n`."
msgstr ""

#: Game.Levels.Algorithm.L07_succnesucc
msgid "Can you take it from here? (note: if you try `contrapose! h` again, it will\n"
"take you back to where you started!)"
msgstr ""

#: Game.Levels.Algorithm.L08_decide_I
msgid "decide"
msgstr ""

#: Game.Levels.Algorithm.L08_decide_I
msgid "# Summary\n"
"\n"
"`decide` will attempt to solve a goal if it can find an algorithm which it\n"
"can run to solve it.\n"
"\n"
"## Example\n"
"\n"
"A term of type `DecidableEq ‚Ñï` is an algorithm to decide whether two naturals\n"
"are equal or different. Hence, once this term is made and made into an `instance`,\n"
"the `decide` tactic can use it to solve goals of the form `a = b` or `a ‚â† b`."
msgstr ""

#: Game.Levels.Algorithm.L08_decide_I
msgid "Implementing the algorithm for equality of naturals, and the proof that it is correct,\n"
"looks like this:\n"
"\n"
"```\n"
"instance instDecidableEq : DecidableEq ‚Ñï\n"
"| 0, 0 => isTrue <| by\n"
"  show 0 = 0\n"
"  rfl\n"
"| succ m, 0 => isFalse <| by\n"
"  show succ m ‚â† 0\n"
"  exact succ_ne_zero m\n"
"| 0, succ n => isFalse <| by\n"
"  show 0 ‚â† succ n\n"
"  exact zero_ne_succ n\n"
"| succ m, succ n =>\n"
"  match instDecidableEq m n with\n"
"  | isTrue (h : m = n) => isTrue <| by\n"
"    show succ m = succ n\n"
"    rw [h]\n"
"    rfl\n"
"  | isFalse (h : m ‚â† n) => isFalse <| by\n"
"    show succ m ‚â† succ n\n"
"    exact succ_ne_succ m n h\n"
"```\n"
"\n"
"This Lean code is a formally verified algorithm for deciding equality\n"
"between two naturals. I've typed it in already, behind the scenes.\n"
"Because the algorithm is formally verified to be correct, we can\n"
"use it in Lean proofs. You can run the algorithm with the `decide` tactic."
msgstr ""

#: Game.Levels.Algorithm.L08_decide_I
msgid "$20+20=40$."
msgstr ""

#: Game.Levels.Algorithm.L08_decide_I
msgid "You can read more about the `decide` tactic by clicking\n"
"on it in the top right."
msgstr ""

#: Game.Levels.Algorithm.L09_decide_II
msgid "decide again"
msgstr ""

#: Game.Levels.Algorithm.L09_decide_II
msgid "We gave a pretty unsatisfactory proof of `2 + 2 ‚â† 5` earlier on; now give a nicer one."
msgstr ""

#: Game.Levels.Algorithm.L09_decide_II
msgid "$2+2 \\neq 5.$"
msgstr ""

#: Game.Levels.Algorithm.L09_decide_II
msgid "Congratulations! You've finished Algorithm World. These algorithms\n"
"will be helpful for you in Even-Odd World."
msgstr ""

#: Game.Levels.Algorithm
msgid "Algorithm World"
msgstr ""

#: Game.Levels.Algorithm
msgid "Proofs like $2+2=4$ and $a+b+c+d+e=e+d+c+b+a$ are very tedious to do by hand.\n"
"In Algorithm World we learn how to get the computer to do them for us.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""

#: Game.Levels.AndIntro.L01_and
msgid "Exactly! It's in the premise"
msgstr ""

#: Game.Levels.AndIntro.L01_and
msgid "# Introduction\n"
"You've made a todo list, so you've begun to plan your party.\n"
"## Proposition Key:\n"
"`P` ‚Äî You're **P**lanning a party\n"
"## Assumptions\n"
"`todo_list : P` ‚Äî Can be read as ‚ÄúThe `todo_list` is evidence that you're `P`lanning a party‚Äù\n"
"# The Exact Tactic\n"
"The Exact tactic is ‚Äî for now ‚Äî the means through which you give the game your answer. It's your way of declaring that you're done. In this level, you're just going to be using one of the assumptions directly, but as you learn how to form expressions the `exact` tactic will accept those too.\\\n"
"\\\n"
"The input will look like `exact e` where `e` is an expression the game will accept for the current Goal.\\\n"
"\\\n"
"‚ãÜSpoilers!‚ãÜ If you enter ‚Äú`exact todo_list`,‚Äù you will have completed this level.\n"
"\n"
"# Become Familiar with the User Interface!\n"
"\n"
"# Proof State\n"
"Found in the middle bottom of the screen, the proof state tells you what objects exist, what assumptions are available, and what goal proposition you're trying to exhibit evidence for. Find the area of the screen with **Objects**, **Assumptions**, and **Goal**. I'll describe each shortly here.\n"
"## 1. Objects:\n"
"In this level, you'll notice that there is only one proposition. `P : Prop` is the game's way of telling you that it knows that `P` is a proposition. You can check out the **Proposition Key** above to learn what it's denoting in this level if you're interested.\n"
"## 2. Assumptions:\n"
"Most levels will give you some starting assumptions that take the form of evidence for some propositions. The shorthand for a proposition traditionally starts with a capital letter and the shorthand for evidence traditionally starts with a lowercase letter.\n"
"## 3. Goal:\n"
"The goal is always a proposition that you want to exhibit some evidence for. In this level, one of your assumptions already contains evidence for the goal. That will certainly not always be the case.\n"
"# Inventory\n"
"On the right of the screen is your inventory of tactics, definitions, and theorems. Once unlocked, you can click them to read about what they do."
msgstr ""

#: Game.Levels.AndIntro.L01_and
msgid "Exhibit evidence that you're planning a party."
msgstr ""

#: Game.Levels.AndIntro.L01_and
msgid "Congratulations, not only have you started your todo list, you've learned how to exhibit the list as evidence that you've started planning the party."
msgstr ""

#: Game.Levels.AndIntro.L02_andprops
msgid "And Introduction"
msgstr ""

#: Game.Levels.AndIntro.L02_andprops
msgid "# `‚àß`\n"
"The hat symbol ‚Äú ‚àß ‚Äù is how logicians denote a conjunction ‚Äî a logical ‚Äúand‚Äù. `A ‚àß B` means ‚ÄúA and B‚Äù. It works the way you would intuitively expect. Like a lot of math operators (`+,-,√∑,√ó`,and others), the `‚àß` symbol is an infix operator. This means it has a left side and a right side. Looking at `A ‚àß B`, you can see that `A` is on the left and `B` is on the right.\n"
"\n"
"# Sending Invitations in a Single Package\n"
"You have two letters, one extending an invitation to Pippin and the other to Sybeth. Since they share a residence, you'd like to consolidate their invites into a single package for shipping. The box you're using has space for two items, one on the left and one on the right.\\\n"
"\\\n"
"You've labelled the box explicitly, specifying that Pippin's invitation is on the left and Sybeth's invitation is on the right. This ensures there's no confusion about the contents of the box. Upon opening it, they will easily locate their respective invites without the need to search the entire package.\n"
"# Proposition Key:\n"
"- P ‚Äî ‚Äú**P**ippin is invited to the party‚Äù\n"
"- S ‚Äî ‚Äú**S**ybeth is invited to the party‚Äù\n"
"\n"
"Like the box described in the intro, any evidence for a conjunction like `A ‚àß B` will have a left part and a right part.\n"
"# Assumptions\n"
"- `p : P` ‚Äî Your invitation for Pippin is evidence that Pippin is invited to the party\n"
"- `s : S` ‚Äî Your invitation for Sybeth is evidence that Sybeth is invited to the party\n"
"# Goal\n"
"Use `p` and `s` to produce evidence that `P ‚àß S`. Remember that you use evidence (generally lowercase letters), to deduce new propositions (generally uppercase letters)\n"
"\n"
"# Using the `‚àß` Construtor\n"
"This level has unlocked ‚Äú`‚àß`‚Äù under definitions. This has made the `and_intro` theorem available. You can use `and_intro` by giving it the two relevant pieces of evidence. The expression looks like: `and_intro e‚ÇÅ e‚ÇÇ` where `e‚ÇÅ` and `e‚ÇÇ` are evidence.\\\n"
"\\\n"
"The help page has even more detail about creating conjunctions like this (There's a common shorthand using angle-brackets `‚ü®` `,` `‚ü©` ).\n"
"\n"
"# A reminder\n"
"Use the `exact` tactic to exhibit evidence for a goal"
msgstr ""

#: Game.Levels.AndIntro.L02_andprops
msgid "Fill a box, label correctly"
msgstr ""

#: Game.Levels.AndIntro.L02_andprops
msgid "exact and_intro p s"
msgstr ""

#: Game.Levels.AndIntro.L02_andprops
msgid "You've got evidence that Pippin and Sybeth are invited to the party.\\\n"
"\\\n"
"Here are some answers the game would have accepted:\n"
"```\n"
"exact and_intro p s\n"
"exact ‚ü®p,s‚ü©\n"
"```"
msgstr ""

#: Game.Levels.AndIntro.L03_have
msgid "The Have Tactic"
msgstr ""

#: Game.Levels.AndIntro.L03_have
msgid "# Too Many Invites\n"
"You have invites for Alarfil, Ilyn, Orin, and Uriel who all live together. Unfortunately, boxes only have space for two items, but you've thought up a clever solution!\n"
"1. You'll put Alarfil's and Ilyn's invites in a box,\n"
"2. You'll put Orin's and Uriel's invites in another box.\n"
"3. You'll put both boxes in a final box.\n"
"### Nested Boxes!\n"
"Nesting boxes like this is a way to get around the ‚Äútwo items per box‚Äù rule. Ensure that everything is correctly labelled to guarantee each invite reaches the correct recipient.\n"
"# Proposition Key:\n"
"- A ‚Äî **A**larfil is invited to the party\n"
"- I ‚Äî **I**lyn is invited to the party\n"
"- O ‚Äî **O**rin is invited to the party\n"
"- U ‚Äî **U**riel is invited to the party\n"
"\n"
"# The `have` Tactic\n"
"You can complete this level with your knowledge from the previous level without using this new tactic. For example, either of these would work:\n"
"```\n"
"exact and_intro (and_intro a i) (and_intro o u)\n"
"exact ‚ü®‚ü®a,i‚ü©,‚ü®o,u‚ü©‚ü©\n"
"```\n"
"Instead of nesting this way, you can break the process down into steps using the `have` tactic. Enter ‚Äú`have ai := and_intro a i`‚Äù to create your first box. After it's entered, it will appear under assumptions in the proof state. Now enter ‚Äú`have ou := and_intro o u`‚Äù to create the second box.\\\n"
"\\\n"
"If you followed this suggestion, your proof state should now have the following assumptions:\n"
"```\n"
"Assumptions:\n"
"a: A\n"
"i: I\n"
"o: O\n"
"u: U\n"
"ai: A ‚àß I\n"
"ou: O ‚àß U\n"
"```\n"
"\\\n"
"Finally, now you can place these two boxes ‚Äî `ai` and `ou` ‚Äî into a third box and submit your answer using the `exact` tactic."
msgstr ""

#: Game.Levels.AndIntro.L03_have
msgid "Three √ó and_intro."
msgstr ""

#: Game.Levels.AndIntro.L03_have
msgid "exact and_intro ¬´{ai}¬ª ¬´{ou}¬ª"
msgstr ""

#: Game.Levels.AndIntro.L03_have
msgid "Great! Another 4 invites sent out. You're getting the hang of this."
msgstr ""

#: Game.Levels.AndIntro.L04_elim_I
msgid "And Elimination"
msgstr ""

#: Game.Levels.AndIntro.L04_elim_I
msgid "# Using Only What Is Needed\n"
"Sybeth has left a voicemail on your answering machine. In it she says ‚ÄúHello, it's Sybeth, I'm calling to confirm that Pippin is coming to the party and I am also coming to the party! See you then!‚Äù\\\n"
"\\\n"
"You'd like to convince Cyna to join the party. You know that Cyna is good friends with Pippin. Constructing evidence that Pippin is attending the party might just be the key to convincing Cyna to join as well.\n"
"# Proposition Key:\n"
"- P ‚Äî \"**P**ippin is coming to the party\"\n"
"- S ‚Äî \"**S**ybeth is coming to the party\"\n"
"# Assumptions:\n"
"- `vm : P ‚àß S` ‚Äî The voicemail (`vm`) is evidence that (`P ‚àß S`) Pippin and Sybeth are coming to the party.\n"
"# Convincing Cyna\n"
"Cyna is close with Pippin, but you don't know much about his friendship with Sybeth. You want only a relevant part of the voicemail. Fortunately, you know that any evidence with an `‚àß` has a left part and a right part. You can use this knowledge to pull evidence out of `vm`.\\\n"
"\\\n"
"This can be done with either of these two methods:\n"
"```\n"
"have p := and_left vm\n"
"have p := vm.left\n"
"```\n"
"Once you've done this, you're very close to level 1 again where the Goal is directly in your assumptions."
msgstr ""

#: Game.Levels.AndIntro.L04_elim_I
msgid "Exhibit evidence that Pippin is coming to the party."
msgstr ""

#: Game.Levels.AndIntro.L04_elim_I
msgid "You've got a proof that Pippin is coming to the party! Lets see if Cyna will attend as well.\n"
"\n"
"----\n"
"A reminder that expressions work with the `have` and `exact` tactics in much the same way. You can also solve this level without `have`.\n"
"```lean\n"
"exact vm.left\n"
"```"
msgstr ""

#: Game.Levels.AndIntro.L05_elim_II
msgid "And Elimination 2"
msgstr ""

#: Game.Levels.AndIntro.L05_elim_II
msgid "# Another Unlock\n"
"Can you figure this one out?"
msgstr ""

#: Game.Levels.AndIntro.L05_elim_II
msgid "Both P and Q entails just Q as well!"
msgstr ""

#: Game.Levels.AndIntro.L05_elim_II
msgid "`exact h.right`"
msgstr ""

#: Game.Levels.AndIntro.L05_elim_II
msgid "Nice. Onward!\n"
"\n"
"----\n"
"```\n"
"exact h.right\n"
"```\n"
"----\n"
"```\n"
"exact and_right h\n"
"```"
msgstr ""

#: Game.Levels.AndIntro.L06_mixmatch
msgid "Mix and Match"
msgstr ""

#: Game.Levels.AndIntro.L06_mixmatch
msgid "# Mixed Up Conjunctions\n"
"Recall when you placed the invites for Alarfil, Ilyn, Orin, and Uriel in separate boxes. There was a mix-up in the arrangement. Can you fix it so that Alarfil and Uriel's invites are together?\n"
"# Proposition Key:\n"
"- A ‚Äî **A**larfil is invited to the party\n"
"- I ‚Äî **I**lyn is invited to the party\n"
"- O ‚Äî **O**rin is invited to the party\n"
"- U ‚Äî **U**riel is invited to the party"
msgstr ""

#: Game.Levels.AndIntro.L06_mixmatch
msgid "and_intro, and_left, and_right"
msgstr ""

#: Game.Levels.AndIntro.L06_mixmatch
msgid "That's better, but you'd better send out those invites so you can get some responses!\n"
"\n"
"----\n"
"```\n"
"have a := h1.left\n"
"have u := h2.right\n"
"exact and_intro a u\n"
"```\n"
"---\n"
"```\n"
"exact and_intro h1.left h2.right\n"
"```\n"
"----\n"
"```\n"
"exact and_intro (and_left h1) (and_right h2)\n"
"```\n"
"---\n"
"```\n"
"exact ‚ü®h1.left, h2.right‚ü©\n"
"```"
msgstr ""

#: Game.Levels.AndIntro.L07_elim_III
msgid "More Elimination"
msgstr ""

#: Game.Levels.AndIntro.L07_elim_III
msgid "# An Emergency!\n"
"Stop with the invites! Coco, your cat is stuck up a tree.\\\n"
"\\\n"
"The firefighters are here but they need your help figuring if they can get to the branch with Coco. They can see the entire tree and they know how to follow the branches by going left or right at each intersection. If they can do that, then they must be able to get to Coco.\n"
"# Proposition Key:\n"
"- C ‚Äî The firefighters can get to Coco\n"
"- L ‚Äî The firefighters can get to some leaves\n"
"# Goal\n"
"Show evidence that the firefighters can get to Coco\n"
"\n"
"# `‚àß` associates to the right\n"
"Check out the definition page for \"Precedence\" to learn a bit more.\n"
"# Hint # 1\n"
"If you hover your mouse over an operator in the proof state it will highlight the part of the expression that it operates **on**. Find the one that highlights the entire expression to see where the trunk of the tree is.\\\n"
"\\\n"
"Another approach is trial and error. Enter `have h‚ÇÅ := h.right` to see `h‚ÇÅ: (L ‚àß L) ‚àß L` appear in your assumptions, which doesn't have `C` anywhere, indicating that this isn't the correct part of the tree. You can hit retry, then change that line to have `h‚ÇÅ := h.left`. Then your assumptions will have `h‚ÇÅ: L ‚àß ((L ‚àß C) ‚àß L) ‚àß L ‚àß L ‚àß L`, which has the `C` somewhere.\n"
"# Hint # 2\n"
"The |**Show more help!**| button below will display the expression for you. Beware, the boss level will not come with this option."
msgstr ""

#: Game.Levels.AndIntro.L07_elim_III
msgid "Navigate the tree"
msgstr ""

#: Game.Levels.AndIntro.L07_elim_III
msgid "h.left.right.left.left.right"
msgstr ""

#: Game.Levels.AndIntro.L07_elim_III
msgid "Amazing! You've helped save your cat!\n"
"\n"
"----\n"
"Here are three solutions, are you able to follow each of them?\n"
"```\n"
"have h‚ÇÅ := and_left h\n"
"have h‚ÇÇ := and_right h‚ÇÅ\n"
"have h‚ÇÉ := and_left h‚ÇÇ\n"
"have h‚ÇÑ := and_left h‚ÇÉ\n"
"have h‚ÇÖ := and_right h‚ÇÑ\n"
"exact h‚ÇÖ\n"
"```\n"
"or\n"
"```\n"
"exact and_right (and_left (and_left (and_right (and_left h))))\n"
"```\n"
"or\n"
"```\n"
"exact h.left.right.left.left.right\n"
"```"
msgstr ""

#: Game.Levels.AndIntro.L08_masterand
msgid "Rearranging Boxes"
msgstr ""

#: Game.Levels.AndIntro.L08_masterand
msgid "# BOSS LEVEL\n"
"If you can finish this level, you've certainly mastered the `‚àß`. There's no deep logical tricks in this boss level, you've just got to know how to work at properly unnesting and then building the right Proposition.\\\n"
"\\\n"
"Using the `have` tactic, you can break this task down into digestible chunks. The top right of the screen has a button that toggles between editor mode and typewriter mode. Editor mode is often a bit easier to work with as it allows you to enter multi-line expressions or edit earlier lines seamlessly. While in editor mode, the proof state will change depending on which line your caret is on.\n"
"# Rearranging Boxes\n"
"Finally, a bunch of your invites have returned with RSVPs. The mailman has delivered them in a big box. Make a list of the expected attendees so far.\n"
"# Proposition Key:\n"
"- A ‚Äî **A**larfil is coming to the party\n"
"- C ‚Äî **C**yna** is coming to the party\n"
"- I ‚Äî **I**lyn** is coming to the party\n"
"- O ‚Äî **O**rin** is coming to the party\n"
"- P ‚Äî **P**ippin** is coming to the party\n"
"- S ‚Äî **S**ybeth** is coming to the party\n"
"- U ‚Äî **U**riel** is coming to the party"
msgstr ""

#: Game.Levels.AndIntro.L08_masterand
msgid "Take apart and build evidence"
msgstr ""

#: Game.Levels.AndIntro.L08_masterand
msgid "Amazing! You've mastered \"AND\".\n"
"\n"
"---\n"
"```\n"
"-- 3/4 of the things you need are one step away\n"
"have psa := h.left\n"
"\n"
"-- Evidence for C takes some digging\n"
"have c := h.right.right.left.left\n"
"\n"
"-- build C ‚àß P ‚àß S\n"
"have cps := and_intro c psa.left\n"
"\n"
"-- exibit A ‚àß C ‚àß P ‚àß S\n"
"exact and_intro psa.right cps\n"
"```"
msgstr ""

#: Game.Levels.AndIntro
msgid "‚àß Tutorial: Party Invites"
msgstr ""

#: Game.Levels.AndIntro
msgid "# Let the festivities commence!\n"
"You're hosting your yearly soir√©e, and it's time to start planning! Last year your planning went so poorly that nobody showed up. Not for lack of trying though, they just wound up at a number of bewildering addresses. The silver lining was that all your friends were safe from the fire when, accidentally, you burned down your entire apartment building.\\\n"
"\\\n"
"This year will be different‚Äº This year, if you want to be sure that there will be fancy cheeses, you had better have evidence that somebody is bringing the cheese platter.\n"
"\n"
"World 1: **Party Invites** is a tutorial world that is meant to introduce you to conjunction ‚Äî the logical ‚Äúand‚Äù. The symbol used to denote an ‚Äúand‚Äù looks like ‚Äú`‚àß`‚Äù. You'll learn to how to use evidence to create an `‚àß` and also how to get evidence out when it's been `‚àß`ed together.\\\n"
"\\\n"
"The real-world analogues for evidence of `A ‚àß B` might be a box with evidence for `A` and evidence for `B`, an audio recording with both pieces of evidence, or a tree with evidence in its branches.\\\n"
"\\\n"
"While real-world analogues can be anything, the abstract machinery used in this game will always be the same. In the case of the `‚àß` operator, the game stores the associated evidence in a tuple data structure.\\\n"
"\\\n"
"The details aren't important. Each level will be encoded for you into the symbols of a proof state. The puzzle, at its core, will be about symbol manipulation. Much of the text is there for added fun and flair.\n"
"\n"
"# **Aside**: Expressions\n"
"If you're coming at this as a puzzle, part of the goal of the tutotial worlds is to teach you how to form expressions and to think about what they evaluate to. Consider how how these expressions all evaluate to the same number:\n"
"```\n"
"4 + 6\n"
"(4) + 6\n"
"(4) + (6)\n"
"3 + 1 + 6\n"
"3 + (1 + 6)\n"
"4 + 4 + 2\n"
"(4 * 2) + 2\n"
"```\n"
"and how some things which may look like expressions really are not:\n"
"```\n"
"4 6\n"
"4 +\n"
"4 (++) 6\n"
"(4 +) 6\n"
"```\n"
"The expressions that this game is asking you to form are mostly in prefix form. In context, this means the operation is given a textual name instead of a symbol and the parameters are separated by spaces **after** the name. For example; the above expressions may look like:\n"
"```\n"
"add 4 6\n"
"add (4) 6\n"
"add (4) (6)\n"
"add (add 3 1) 6\n"
"add 3 (add 1 6)\n"
"add (add 4 4) 2\n"
"add (mul 4 2) 2\n"
"```\n"
"We're not using expressions to express numbers, but many of the concepts do carry over. Instead of numbers, we're working with logical inferences."
msgstr ""

#: Game
msgid "Intro to Lean"
msgstr ""

#: Game
msgid "# An Intro to Lean by the University of Hyperion\n"
"\n"
"## Content\n"
"* Basics: Proving the simplest theorem, $1 + 1 = 2$.\n"
"### Mathematics\n"
"* Addition: Defining Addition.\n"
"* Multiplication: Defining Multiplication.\n"
"* Power: Defining Exponentiation to (sorta) prove FLT.\n"
"### Logic\n"
"* Implication: Proving the converse, $2 + 2 ‚â† 5$.\n"
"### Automation\n"
"* Algorithm: Automating some of our proofs."
msgstr ""

#: Game
msgid "Here you can put additional information about the game. It is accessible\n"
"from the starting through the drop-down menu.\n"
"\n"
"For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Use markdown."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
