msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Oct 16 01:17:04 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "On: rfl"
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical theorem (the \"Goal\").\n"
"The goal will be a statement about *numbers*. Some numbers in this game have known values.\n"
"Those numbers have names like $37$. Other numbers will be secret. They're called things\n"
"like $x$ and $q$. We know $x$ is a number, we just don't know which one.\n"
"\n"
"In this first level we're going to prove the theorem that $37x + q = 37x + q$.\n"
"You can see `x q : ‚Ñï` in the *Objects* below, which means that `x` and `q`\n"
"are numbers.\n"
"\n"
"We solve goals in Lean using *Tactics*, and the first tactic we're\n"
"going to learn is called `rfl`, which proves all theorems of the form $X = X$.\n"
"\n"
"Prove that $5x+q=5x+q$ by executing the `rfl` tactic."
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "If $x, q ‚àà ‚Ñï$, then $5x + q = 5x + q$"
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "In order to use the tactic `rfl` you can enter it in the text box\n"
"under the goal and hit \"Execute\"."
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "Congratulations! You completed your first verified proof!\n"
"\n"
"Remember that `rfl` is a *tactic*. If you ever want information about the `rfl` tactic,\n"
"you can click on `rfl` in the list of tactics on the right.\n"
"\n"
"Now click on \"Next\" to learn about the `rw` tactic."
msgstr ""

#: Game.Levels.Basics.L01_rfl
msgid "## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\".\n"
"\n"
"## Game Implementation\n"
"\n"
"*Note that our `rfl` is weaker than the version used in core Lean and `mathlib`,\n"
"for pedagogical purposes; mathematicians do not distinguish between propositional\n"
"and definitional equality because they think about definitions in a different way\n"
"to type theorists (`zero_add` and `add_zero` are both \\\"facts\\\" as far\n"
"as mathematicians are concerned, and who cares what the definition of addition is).*"
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "the rw tactic"
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targetted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rewrite 37 [h]`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "In this level the *goal* is $2y=2(x+7)$ but to help us we\n"
"have an *assumption* `h` saying that $y = x + 7$. Check that you can see `h` in\n"
"your list of assumptions. Lean thinks of `h` as being a secret proof of the\n"
"assumption, rather like `x` is a secret number.\n"
"\n"
"Before we can use `rfl`, we have to \"substitute in for $y$\".\n"
"We do this in Lean by *rewriting* the proof `h`,\n"
"using the `rw` tactic."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "If $x$ and $y$ are natural numbers, and $y = x + 7$, then $2y = 2(x + 7)$."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "First execute `rw [h]` to replace the `y` with `x + 7`."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "Can you take it from here? Click on \"Show more help!\" if you need a hint."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "Now `rfl` will work."
msgstr ""

#: Game.Levels.Basics.L02_rw
msgid "You now know enough tactics to prove `1 + 1 = 2`! Let's begin the journey."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Numbers"
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`‚Ñï` is the natural numbers, just called \\\"numbers\\\" in this game. It's\n"
"defined via two rules:\n"
"\n"
"* `0 : ‚Ñï` (zero is a number)\n"
"* `succ (n : ‚Ñï) : ‚Ñï` (the successor of a number is a number)\n"
"\n"
"## Game Implementation\n"
"\n"
"*The game uses its own copy of the natural numbers, called `MyNat` with notation `‚Ñï`.\n"
"It is distinct from the Lean natural numbers `Nat`, which should hopefully\n"
"never leak into the natural number game.*"
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`one_eq_succ_zero` is a proof of `1 = succ 0`.\""
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`two_eq_succ_one` is a proof of `2 = succ 1`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`three_eq_succ_two` is a proof of `3 = succ 2`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "`four_eq_succ_three` is a proof of `4 = succ 3`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "## The birth of number.\n"
"\n"
"Numbers in Lean are defined by two rules.\n"
"\n"
"* `0` is a number.\n"
"* If `n` is a number, then the *successor* `succ n` of `n` is a number.\n"
"\n"
"The successor of `n` means the number after `n`. Let's learn to\n"
"count, and name a few small numbers.\n"
"\n"
"## Counting to four.\n"
"\n"
"`0` is a number, so `succ 0` is a number. Let's call this new number `1`.\n"
"Similarly let's define `2 = succ 1`, `3 = succ 2` and `4 = succ 3`.\n"
"This gives us plenty of numbers to be getting along with.\n"
"\n"
"The *proof* that `2 = succ 1` is called `two_eq_succ_one`.\n"
"Check out the \"012\" tab in the list of lemmas on the right\n"
"for this and other proofs.\n"
"\n"
"Let's prove that $2$ is the number after the number after zero."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "$2$ is the number after the number after $0$."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Start with `rw [two_eq_succ_one]` to begin to break `2` down into its definition."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Can you take it from here?"
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Next turn `1` into `succ 0` with `rw [one_eq_succ_zero]`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Now finish the job with `rfl`."
msgstr ""

#: Game.Levels.Basics.L03_num
msgid "Note that you can do `rw [two_eq_succ_one, one_eq_succ_zero]`\n"
"and then `rfl` to solve this level in two lines."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "rewriting backwards"
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "If `h` is a proof of `X = Y` then `rw [h]` will\n"
"turn `X`s into `Y`s. But what if we want to\n"
"turn `Y`s into `X`s? To tell the `rw` tactic\n"
"we want this, we use a left arrow `‚Üê`. Type\n"
"`\\l` and then hit the space bar to get this arrow.\n"
"\n"
"Let's prove that $2$ is the number after the number\n"
"after $0$ again, this time by changing `succ (succ 0)`\n"
"into `2`."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "$2$ is the number after the number after $0$."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Try `rw [‚Üê one_eq_succ_zero]` to change `succ 0` into `1`."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Can you now change the goal into `2 = 2`?"
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Now `rw [‚Üê two_eq_succ_one]` will change `succ 1` into `2`."
msgstr ""

#: Game.Levels.Basics.L04_revrw
msgid "Why did we not just define `succ n` to be `n + 1`? Because we have not\n"
"even *defined* addition yet! We'll do that in the next level."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "Adding zero"
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "`Add a b`, with notation `a + b`, is\n"
"the usual sum of natural numbers. Internally it is defined\n"
"via the following two hypotheses:\n"
"\n"
"* `add_zero a : a + 0 = a`\n"
"\n"
"* `add_succ a b : a + succ b = succ (a + b)`\n"
"\n"
"Other theorems about naturals, such as `zero_add a : 0 + a = a`, are proved\n"
"by induction using these two basic theorems.\""
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "`add_zero a` is a proof that `a + 0 = a`.\n"
"\n"
"## Summary\n"
"\n"
"`add_zero` is really a function, which\n"
"eats a number, and returns a proof of a theorem\n"
"about that number. For example `add_zero 37` is\n"
"a proof that `37 + 0 = 37`.\n"
"\n"
"The `rw` tactic will accept `rw [add_zero]`\n"
"and will try to figure out which number you omitted\n"
"to input.\n"
"\n"
"## Details\n"
"\n"
"A mathematician sometimes thinks of `add_zero`\n"
"as \\\"one thing\\\", namely a proof of $\\forall n ‚àà ‚Ñï, n + 0 = n$.\n"
"This is just another way of saying that it's a function which\n"
"can eat any number n and will return a proof that `n + 0 = n`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "We'd like to prove `2 + 2 = 4` but right now\n"
"we can't even *state* it\n"
"because we haven't yet defined addition.\n"
"\n"
"## Defining addition.\n"
"\n"
"How are we going to add $37$ to an arbitrary number $x$? Well,\n"
"there are only two ways to make numbers in this game: $0$\n"
"and successors. So to define `37 + x` we will need\n"
"to know what `37 + 0` is and what `37 + succ x` is.\n"
"Let's start with adding `0`.\n"
"\n"
"### Adding 0\n"
"\n"
"To make addition agree with our intuition, we should *define* `37 + 0`\n"
"to be `37`. More generally, we should define `a + 0` to be `a` for\n"
"any number `a`. The name of this proof in Lean is `add_zero a`.\n"
"For example `add_zero 37` is a proof of `37 + 0 = 37`,\n"
"`add_zero x` is a proof of `x + 0 = x`, and `add_zero` is a proof\n"
"of `? + 0 = ?`.\n"
"\n"
"We write `add_zero x : x + 0 = x`, so `proof : statement`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "$a+(b+0)+(c+0)=a+b+c.$"
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "`rw [add_zero]` will change `b + 0` into `b`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "Now `rw [add_zero]` will change `c + 0` into `c`."
msgstr ""

#: Game.Levels.Basics.L05_add_I
msgid "Those of you interested in speedrunning the game may want to know\n"
"that `repeat rw [add_zero]` will do both rewrites at once."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "Precision rewriting"
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "## Precision rewriting\n"
"\n"
"In the last level, there was `b + 0` and `c + 0`,\n"
"and `rw [add_zero]` changed the first one it saw,\n"
"which was `b + 0`. Let's learn how to tell Lean\n"
"to change `c + 0` first by giving `add_zero` an\n"
"explicit input."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "$a+(b+0)+(c+0)=a+b+c.$"
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "Try `rw [add_zero c]`."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "`add_zero c` is a proof of `c + 0 = c` so that was what got rewritten.\n"
"You can now change `b + 0` to `b` with `rw [add_zero]` or `rw [add_zero b]`. You\n"
"can usually stick to `rw [add_zero]` unless you need real precision."
msgstr ""

#: Game.Levels.Basics.L06_add_II
msgid "Let's now learn about Peano's second axiom for addition, `add_succ`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "add_succ"
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "`add_succ a b` is the proof of `a + succ b = succ (a + b)`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "`succ_eq_add_one n` is the proof that `succ n = n + 1`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "Every number in Lean is either $0$ or a successor. We know how to add $0$,\n"
"but we need to figure out how to add successors. Let's say we already know\n"
"that `37 + d = q`. What should the answer to `37 + succ d` be? Well,\n"
"`succ d` is one bigger than `d`, so `37 + succ d` should be `succ q`,\n"
"the number one bigger than `q`. More generally `x + succ d` should\n"
"be `succ (x + d)`. Let's add this as a lemma.\n"
"\n"
"* `add_succ x d : x + succ d = succ (x + d)`\n"
"\n"
"If you ever see `... + succ ...` in your goal, `rw [add_succ]` is\n"
"normally a good idea.\n"
"\n"
"Let's now prove that `succ n = n + 1`. Figure out how to get `+ succ` into\n"
"the picture, and then `rw [add_succ]`. Switch between the `+` (addition) and\n"
"`012` (numerals) tabs under \"Theorems\" on the right to\n"
"see which proofs you can rewrite."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "For all natural numbers $a$, we have $\\operatorname{succ}(a) = a+1$."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "Start by unravelling the `1`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "`rw [one_eq_succ_zero]` will do this."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "Now you can `rw [add_succ]`"
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "And now `rw [add_zero]`"
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "And finally `rfl`."
msgstr ""

#: Game.Levels.Basics.L07_addsucc
msgid "[dramatic music]. Now are you ready to face the first boss of the game?"
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "1+1=2"
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "Good luck!\n"
"\n"
"  One last hint. If `h : X = Y` then `rw [h]` will change *all* `X`s into `Y`s.\n"
"  If you only want to change one of them, say the 3rd one, then use\n"
"  `nth_rewrite 3 [h]`."
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "$1+1=2$."
msgstr ""

#: Game.Levels.Basics.L08_two
msgid "Here's another proof of $1 + 1 = 2$ that uses less lines:\n"
"```lean\n"
"nth_rewrite 2 [one_eq_succ_zero] -- Changes only the second one\n"
"rw [add_succ]\n"
"rw [add_zero]\n"
"rw [‚Üê two_eq_succ_one] -- change `succ 1` to `2`\n"
"rfl\n"
"```\n"
"\n"
"Optional extra: you can run this proof yourself. Switch the game into \"Editor mode\" by clicking\n"
"on the `</>` button in the top right. You can now see your proof\n"
"written as several lines of code. Move your cursor between lines to see\n"
"the goal state at any point. Now cut and paste your code elsewhere if you\n"
"want to save it, and paste the above proof in instead. Move your cursor\n"
"around to investigate. When you've finished, click the `>_` button in the top right to\n"
"move back into \"Typewriter mode\".\n"
"\n"
"You have finished the Basics world!\n"
"Click \"Leave World\" to go back to the\n"
"overworld, and select Addition World, where you will learn\n"
"about the `induction` tactic."
msgstr ""

#: Game.Levels.Basics
msgid "The Basics of Lean"
msgstr ""

#: Game.Levels.Basics
msgid "This introduction is shown before one enters level 1 of the demo world. Use markdown."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "zero_add"
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "In this level we're going to prove that $0+n=n$, where $n$ is a secret natural number.\n"
"\n"
"Wait, don't we already know that? No! We know that $n+0=n$, but that's `add_zero`.\n"
"This is `zero_add`, which is different.\n"
"\n"
"The difficulty with proving `0 + n = n` is that we do not have a *formula* for\n"
"`0 + n` in general, we can only use `add_zero` and `add_succ` once\n"
"we know whether `n` is `0` or a successor. The `induction` tactic splits into these two cases.\n"
"\n"
"The base case will require us to prove `0 + 0 = 0`, and the inductive step\n"
"will ask us to show that if `0 + d = d` then `0 + succ d = succ d`. Because\n"
"`0` and successor are the only way to make numbers, this will cover all the cases.\n"
"\n"
"See if you can do your first induction proof in Lean.\n"
"\n"
"(By the way, if you are still in the \"Editor mode\" from the last world, you can swap\n"
"back to \"Typewriter mode\" by clicking the `>_` button in the top right.)"
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "`zero_add x` is the proof of `0 + x = x`.\n"
"\n"
"`zero_add` is a `simp` lemma, because replacing `0 + x` by `x`\n"
"is almost always what you want to do if you're simplifying an expression."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "For all natural numbers $n$, we have $0 + n = n$."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "You can start a proof by induction on `n` by typing:\n"
"`induction n with d hd`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "Now you have two goals. Once you proved the first, you will jump to the second one.\n"
"This first goal is the base case $n = 0$.\n"
"\n"
"Recall that you can rewrite the proof of any lemma which is visible\n"
"in your inventory, or of any assumption displayed above the goal,\n"
"as long as it is of the form `X = Y`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "try rewriting `add_zero`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "Now for to the second goal. Here you have the induction hypothesis\n"
"`¬´{hd}¬ª : 0 + ¬´{d}¬ª = ¬´{d}¬ª`, and you need to prove that `0 + succ ¬´{d}¬ª = succ ¬´{d}¬ª`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "Use `add_succ`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "At this point you see the term `0 + ¬´{d}¬ª`, so you can use the\n"
"induction hypothesis with `rw [¬´{hd}¬ª]`."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "## Summary\n"
"\n"
"If `n : ‚Ñï` is an object, and the goal mentions `n`, then `induction n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.Addition.L01_intro
msgid "This lemma would have been easy if we had known that `x + y = y + x`. That theorem\n"
"  is called `add_comm` and it is *true*, but unfortunately its proof *uses* both\n"
"  `add_zero` and `zero_add`!\n"
"\n"
"  Let's continue on our journey to `add_comm`, the proof of `x + y = y + x`."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "succ_add"
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Oh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add a b`\n"
"is the proof that `(succ a) + b = succ (a + b)` for `a` and `b` numbers.\n"
"This result is what's standing in the way of `x + y = y + x`. Again\n"
"we have the problem that we are adding `b` to things, so we need\n"
"to use induction to split into the cases where `b = 0` and `b` is a successor."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "`succ_add a b` is a proof that `succ a + b = succ (a + b)`."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "For all natural numbers $a, b$, we have\n"
"$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "You might want to think about whether induction\n"
"on `a` or `b` is the best idea."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Induction on `a` will not work here. You are still stuck with an `+ b`.\n"
"I suggest you delete this line and try a different approach."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Note that `succ a + ¬´{d}¬ª` means `(succ a) + ¬´{d}¬ª`. Put your cursor\n"
"on any `succ` in the goal or assumptions to see what exactly it's eating."
msgstr ""

#: Game.Levels.Addition.L02_succadd
msgid "Well done! You now have enough tools to tackle the main boss of this level."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "add_comm (level boss)"
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "[boss battle music]\n"
"Time to prove one of the most important properties yet: Addition's Commutativity\n"
"\n"
"Look in your inventory to see the proofs you have available.\n"
"These should be enough."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "`add_comm x y` is a proof of `x + y = y + x`."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "On the set of natural numbers, addition is commutative.\n"
"In other words, if `a` and `b` are arbitrary natural numbers, then\n"
"$a + b = b + a$."
msgstr ""

#: Game.Levels.Addition.L03_addcomm
msgid "Induction on `a` or `b` -- it's all the same in this one."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "add_assoc (associativity of addition)"
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "We've been adding up two numbers; in this level we will add up three.\n"
"\n"
"  What does $x+y+z$ *mean*? It could either mean $(x+y)+z$, or it\n"
"  could mean $x+(y+z)$. In Lean, $x+y+z$ means $(x+y)+z$.\n"
"\n"
"  But why do we care which one it means; $(x+y)+z$ and $x+(y+z)$ are *equal*!\n"
"\n"
"  That's true, but we didn't prove it yet. Let's prove it now by induction."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "`add_assoc a b c` is a proof\n"
"that `(a + b) + c = a + (b + c)`. Note that in Lean `(a + b) + c` prints\n"
"as `a + b + c`, because the notation for addition is defined to be left\n"
"associative."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "On the set of natural numbers, addition is associative.\n"
"In other words, if $a, b$ and $c$ are arbitrary natural numbers, we have\n"
"$ (a + b) + c = a + (b + c). $"
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "Remember that when Lean writes `a + b + c`, it means `(a + b) + c`.\n"
"If you are not sure where the brackets are in an expression, just hover\n"
"your cursor over it and look at what gets highlighted. For example,\n"
"hover over both `+` symbols on the left hand side of the goal and\n"
"you'll see where the invisible brackets are."
msgstr ""

#: Game.Levels.Addition.L04_addassoc
msgid "A passing mathematician congratulates you on proving that naturals\n"
"are an additive commutative monoid.\n"
"\n"
"Let's practice using `add_assoc` and `add_comm` in one more level,\n"
"before we leave addition world."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "add_right_comm"
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "`add_comm b c` is a proof that `b + c = c + b`. But if your goal\n"
"is `a + b + c = a + c + b` then `rw [add_comm b c]` will not\n"
"work! Because the goal means `(a + b) + c = (a + c) + b` so there\n"
"is no `b + c` term *directly* in the goal.\n"
"\n"
"Use associativity and commutativity to prove `add_right_comm`.\n"
"You don't need induction. `add_assoc` moves brackets around,\n"
"and `add_comm` moves variables around.\n"
"\n"
"Remember that you can do more targetted rewrites by\n"
"adding explicit variables as inputs to theorems. For example `rw [add_comm b]`\n"
"will only do rewrites of the form `b + ? = ? + b`, and `rw [add_comm b c]`\n"
"will only do rewrites of the form `b + c = c + b`."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "`add_right_comm a b c` is a proof that `(a + b) + c = (a + c) + b`\n"
"\n"
"In Lean, `a + b + c` means `(a + b) + c`, so this result gets displayed\n"
"as `a + b + c = a + c + b`."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "If $a, b$ and $c$ are arbitrary natural numbers, we have\n"
"$(a + b) + c = (a + c) + b$."
msgstr ""

#: Game.Levels.Addition.L05_radcomm
msgid "You've now seen all the tactics you need to beat the final boss of the game.\n"
"You can begin the journey towards this boss by entering Multiplication World.\n"
"\n"
"Or you can go off the beaten track and learn some new tactics in Implication\n"
"World. These tactics let you prove more facts about addition, such as\n"
"how to deduce `a = 0` from `x + a = x`.\n"
"\n"
"Click \"Leave World\" and make your choice."
msgstr ""

#: Game.Levels.Addition
msgid "Addition World"
msgstr ""

#: Game.Levels.Addition
msgid "Welcome to Addition World! In this world we'll learn the `induction` tactic.\n"
"This will enable us to defeat the boss level of this world, namely `x + y = y + x`.\n"
"\n"
"The tactics `rw`, `rfl` and `induction` are the only tactics you'll need to\n"
"beat all the levels in Addition World, Multiplication World, and Power World.\n"
"Power World contains the final boss of the game.\n"
"\n"
"There are plenty more tactics in this game, but you'll only need to know them if you\n"
"want to explore the game further (for example if you decide to 100%\n"
"the game)."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "mul_one"
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "See the new \"*\" tab in your lemmas, containing `mul_zero` and `mul_succ`.\n"
"Right now these are the only facts we know about multiplication.\n"
"Let's prove nine more.\n"
"\n"
"Let's start with a warm-up: no induction needed for this one,\n"
"because we know `1` is a successor."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`Mul a b`, with notation `a * b`, is the usual\n"
"  product of natural numbers. Internally it is\n"
"  via two axioms:\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"\n"
"  * `mul_succ a b : a * succ b = a * b + a`\n"
"\n"
"Other theorems about naturals, such as `zero_mul`,\n"
"are proved by induction from these two basic theorems."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`mul_zero m` is the proof that `m * 0 = 0`."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`mul_succ a b` is the proof that `a * succ b = a * b + a`."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "`mul_one m` is the proof that `m * 1 = m`."
msgstr ""

#: Game.Levels.Multiplication.L01_mulone
msgid "For any natural number $m$, we have $ m \\times 1 = m$."
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "zero_mul"
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "Our first challenge is `mul_comm x y : x * y = y * x`,\n"
"and we want to prove it by induction. The zero\n"
"case will need `mul_zero` (which we have)\n"
"and `zero_mul` (which we don't), so let's\n"
"start with this."
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "`zero_mul x` is the proof that `0 * x = 0`.\n"
"\n"
"Note: `zero_mul` is a `simp` lemma."
msgstr ""

#: Game.Levels.Multiplication.L02_zeromul
msgid "For all natural numbers $m$, we have $ 0 \\times m = 0$."
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "succ_mul"
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "Similarly we have `mul_succ`\n"
"but we're going to need `succ_mul` (guess what it says -- maybe you\n"
"are getting the hang of Lean's naming conventions).\n"
"\n"
"The last level from addition world might help you in this level.\n"
"If you can't remember what it is, you can go back to the\n"
"home screen by clicking the house icon and then taking a look.\n"
"You won't lose any progress."
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "`succ_mul a b` is the proof that `succ a * b = a * b + b`.\n"
"\n"
"It could be deduced from `mul_succ` and `mul_comm`, however this argument\n"
"would be circular because the proof of `mul_comm` uses `mul_succ`."
msgstr ""

#: Game.Levels.Multiplication.L03_succmul
msgid "For all natural numbers $a$ and $b$, we have\n"
"$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$."
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "mul_comm"
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "The first sub-boss of Multiplication World is `mul_comm x y : x * y = y * x`.\n"
"\n"
"When you've proved this theorem we will have \"spare\" proofs\n"
"such as `zero_mul`, which is now easily deducible from `mul_zero`.\n"
"But we'll keep hold of these proofs anyway, because it's convenient\n"
"to have exactly the right tool for a job."
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "`mul_comm` is the proof that multiplication is commutative. More precisely,\n"
"`mul_comm a b` is the proof that `a * b = b * a`."
msgstr ""

#: Game.Levels.Multiplication.L04_mulcomm
msgid "Multiplication is commutative."
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "one_mul"
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "You can prove $1\\times m=m$ in at least three ways.\n"
"Either by induction, or by using `succ_mul`, or\n"
"by using commutativity. Which do you think is quickest?"
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "`one_mul m` is the proof `1 * m = m`."
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "For any natural number $m$, we have $ 1 \\times m = m$."
msgstr ""

#: Game.Levels.Multiplication.L05_onemul
msgid "Here's my solution:\n"
"```\n"
"rw [mul_comm, mul_one]\n"
"rfl\n"
"```"
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "two_mul"
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "This level is more important than you think; it plays\n"
"a useful role when battling a big boss later on."
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "`two_mul m` is the proof that `2 * m = m + m`."
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "For any natural number $m$, we have $ 2 \\times m = m+m$."
msgstr ""

#: Game.Levels.Multiplication.L06_twomul
msgid "Here's my solution:\n"
"```\n"
"rw [two_eq_succ_one, succ_mul, one_mul]\n"
"rfl\n"
"```"
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "mul_add"
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Our next goal is \"left and right distributivity\",\n"
"meaning $a(b+c)=ab+ac$ and $(b+c)a=ba+ca$. Rather than\n"
"these slightly pompous names, the name of the proofs\n"
"in Lean are descriptive. Let's start with\n"
"`mul_add a b c`, the proof of `a * (b + c) = a * b + a * c`.\n"
"Note that the left hand side contains a multiplication\n"
"and then an addition."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Multiplication distributes\n"
"over addition on the left.\n"
"\n"
"`mul_add a b c` is the proof that `a * (b + c) = a * b + a * c`."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Multiplication is distributive over addition on the left.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$a(b + c) = ab + ac$."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "You can do induction on any of the three variables. Some choices\n"
"are harder to push through than others. Can you do the inductive step in\n"
"5 rewrites only?"
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Induction on `a` is the most troublesome, then `b`,\n"
"and `c` is the easiest."
msgstr ""

#: Game.Levels.Multiplication.L07_muladd
msgid "Here's my solution:\n"
"```\n"
"induction c with d hd\n"
"rw [add_zero, mul_zero, add_zero]\n"
"rfl\n"
"rw [add_succ, mul_succ, hd, mul_succ, add_assoc]\n"
"rfl\n"
"```\n"
"\n"
"Inducting on `a` or `b` also works, but might take longer."
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "add_mul"
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "`add_mul` is just as fiddly to prove by induction; but there's a trick\n"
"which avoids it. Can you spot it?"
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "`add_mul a b c` is a proof that $(a+b)c=ac+bc$."
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "Addition is distributive over multiplication.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(a + b) \\times c = ac + bc$."
msgstr ""

#: Game.Levels.Multiplication.L08_addmul
msgid "Here's my proof:\n"
"```\n"
"rw [mul_comm, mul_add]\n"
"repeat rw [mul_comm c]\n"
"rfl\n"
"```"
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "mul_assoc"
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "We now have enough to prove that multiplication is associative,\n"
"the boss level of multiplication world. Good luck!"
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "`mul_assoc a b c` is a proof that `(a * b) * c = a * (b * c)`.\n"
"\n"
"Note that when Lean says `a * b * c` it means `(a * b) * c`.\n"
"\n"
"Note that `(a * b) * c = a * (b * c)` cannot be proved by \\\"pure thought\\\":\n"
"for example subtraction is not associative, as `(6 - 2) - 1` is not\n"
"equal to `6 - (2 - 1)`."
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "Multiplication is associative.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(ab)c = a(bc)$."
msgstr ""

#: Game.Levels.Multiplication.L09_mulassoc
msgid "A passing mathematician notes that you've proved\n"
"that the natural numbers are a commutative semiring.\n"
"\n"
"If you want to begin your journey to the final boss, head for Power World."
msgstr ""

#: Game.Levels.Multiplication
msgid "Multiplication World"
msgstr ""

#: Game.Levels.Multiplication
msgid "How should we define `37 * x`? Just like addition, we need to give definitions\n"
"when $x=0$ and when $x$ is a successor.\n"
"\n"
"The zero case is easy: we define `37 * 0` to be `0`. Now say we know\n"
"`37 * d`. What should `37 * succ d` be? Well, that's $(d+1)$ $37$s,\n"
"so it should be `37 * d + 37`.\n"
"\n"
"Here are the definitions in Lean.\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"  * `mul_succ a d : a * succ d = a * d + a`\n"
"\n"
"In this world, we must not only prove facts about multiplication like `a * b = b * a`,\n"
"we must also prove facts about how multiplication interacts with addition, like `a * (b + c) = a * b + a * c`.\n"
"Let's get started."
msgstr ""

#: Game
msgid "Intro to Lean"
msgstr ""

#: Game
msgid "# An Intro to Lean by the University of Hyperion\n"
"\n"
"## Content\n"
"* Basics: Proving the simplest theorem, $1 + 1 = 2$\n"
"* Addition: Defining Addition"
msgstr ""

#: Game
msgid "Here you can put additional information about the game. It is accessible\n"
"from the starting through the drop-down menu.\n"
"\n"
"For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Use markdown."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
